(function () {
    "use strict";
    if (!String.prototype.startsWith) {
        String.prototype.startsWith = function (searchString, position) {
            position = position || 0;
            return this.indexOf(searchString, position) === position;
        };
    }

    if (!String.prototype.format) {
        String.prototype.format = function () {
            var args = arguments;
            return this.replace(/{(\d+)}/g, function (match, number) {
                return typeof args[number] != 'undefined'
                  ? args[number]
                  : match
                ;
            });
        };
    }
})();
var globalApp = angular.module('globalApp', [
    "ngAnimate",
    "ui.bootstrap",
    "ui.mask",
    "ui.validate",
    "ui.tinymce",
    "ngResource",
    "ngRoute",
    "ngCookies",
    "ngSanitize",
    "angucomplete-alt",
    'jcs.angular-http-batch',
    "angular-cache",
    "lodash",
    "angular.bind.notifier",
    "lk-google-picker",
    "dropbox-picker",
    "vcRecaptcha",
    "sticky",
    "matchMedia" //https://github.com/jacopotarantino/angular-match-media
]);






//
//   this config should be in a service and off of this page
//
//
(function () {
    'use strict';
    angular.module('globalApp').config(['$logProvider', 'lkGoogleSettingsProvider', 'DropBoxSettingsProvider', configFunction]);

    function configFunction($logProvider, lkGoogleSettingsProvider, DropBoxSettingsProvider) {
        $logProvider.debugEnabled(true);

        ///TODO: Move ApiKey and ClientId to ChannelConfig.
        lkGoogleSettingsProvider.configure({
            apiKey: 'AIzaSyAgqvKJrJAl_fkYueUcH9fuz7yJJiyUobU', 
            clientId: '795743966271-muv79fkqpjhqo8pan5rp7b9gedl4b1vm.apps.googleusercontent.com',
            scopes: ['https://www.googleapis.com/auth/drive.readonly']
        });

        DropBoxSettingsProvider.configure({
            linkType: 'direct',//dropbox link type
            multiselect: false,//dropbox multiselect
            extensions: ['.pdf', '.doc', '.docx', '.gif', '.jpg', 'png']//dropbox file extensions
        });
    };

})();

(function (angular) {
    'use strict';
    angular.module('globalApp').config([
      '$provide',
      function ($provide) {
          $provide.decorator('$templateCache', ['$delegate', function ($delegate) {
              var originalGet = $delegate.get;
              var originalPut = $delegate.put;

              $delegate.get = function (key) {
                  return originalGet(key.toLowerCase());
              };
              $delegate.put = function (key, value) {
                  originalPut(key.toLowerCase(), value);
              };

              return $delegate;
          }]);

          return this;
      }
    ]);
})(angular);

(function (angular) {
    'use strict';
    angular.module('globalApp').config(['$sceDelegateProvider', function ($sceDelegateProvider) {
        $sceDelegateProvider.resourceUrlWhitelist([
          // Allow same origin resource loads.
          'self',
          // Allow loading from our assets domain.  Notice the difference between * and **.
          'https://core.ui.lexus.monster.com/**']);
    }]);
})(angular);

//
//  Batching URL hack
//
var disablebatchingcookie = 'disablebatching';

var batchingparam = getParameterByName(disablebatchingcookie);
if(batchingparam) {
    setCookie(disablebatchingcookie, batchingparam, 1);
} else {
    batchingparam = getCookie(disablebatchingcookie)
}

if(batchingparam != "true") {
(function (angular) {
    'use strict';
    angular.module('globalApp').config(['httpBatchConfigProvider',
       function (httpBatchConfigProvider) {
           httpBatchConfigProvider.setAllowedBatchEndpoint(
                'https://services.lexus.monster.com',
                'https://services.lexus.monster.com/api/batch',
                {
                    maxBatchedRequestPerCall: 20,
                    excludes: [
                        'pdfresume'
                    ]
                });
       }
    ]);
})(angular);
}

//
// EO
//

// configure tracking providers
(function () {
    'use strict';
    angular.module('globalApp').run(['trackService', 'adobeTracking', runFunction]);
    function runFunction(trackService, adobeTracking) {
        trackService.addSink(adobeTracking);
    }
})();

// this should be the only run on this page
(function () {
    'use strict';

    angular.module('globalApp').run(['$rootScope', 'productVariables', 'lookUpGlobalJson', 'logInWatcher', 'gotoAnchor', 'registry', 'contextService', 'coreUiTemplateService', 'trackService', runFunction]);
    function runFunction($rootScope, productVariables, lookUpGlobalJson, logInWatcher, gotoAnchor, registry, contextService, coreUiTemplateService, trackService) {
        registry.init();          // initilizes the regestry from web storage
        contextService.init();
        coreUiTemplateService.init(); // caches templates; note this service is being defined via gulp
        productVariables.init();  // adds the rootscope product variables
        lookUpGlobalJson.init();  // add rootscope functions for the templates to get messages and configs
        logInWatcher.init();      // adds the log in rootscope watcher function
        gotoAnchor.init();        // adds an angular polyfill to goto #anchor 
        trackService.init();      // add track function 
    }

})();


// this needs to be refactored so it can work fron the above function
(function () {
    'use strict';

    // has to run after rootScope was initialized
    angular.module('globalApp').run(['authentication', '$rootScope', 'timeoutManager', runFunction]);
    function runFunction(authentication, $rootScope, timeoutManager) {
        authentication.scheduleRenewal();
    };


})();

//
// TEMP BATCHING OVERRIDE
// DELETE AFTER 500 IS SOLVED
//

function setCookie(cname, cvalue, exdays) {
    var d = new Date();
    d.setTime(d.getTime() + (exdays*24*60*60*1000));
    var expires = "expires="+ d.toUTCString();
    document.cookie = cname + "=" + cvalue + "; " + expires;
}

function getCookie(cname) {
    var name = cname + "=";
    var ca = document.cookie.split(';');
    for(var i = 0; i <ca.length; i++) {
        var c = ca[i];
        while (c.charAt(0)==' ') {
            c = c.substring(1);
        }
        if (c.indexOf(name) == 0) {
            return c.substring(name.length,c.length);
        }
    }
    return "";
}

function getParameterByName(name, url) {
    if (!name) return "";
    if (!url) url = window.location.href;
    name = name.replace(/[\[\]]/g, "\\$&");
    var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
        results = regex.exec(url);
    if (!results) return null;
    if (!results[2]) return '';
    return decodeURIComponent(results[2].replace(/\+/g, " "));
}
//
// EO
//
(function () {
    angular.module('globalApp').run(['$rootScope', '$window', run]);

    function run($rootScope, $window) {
        $rootScope.meta = {
            messages: {
                555: { lookUpMsg: { id: 555, text: 'required' } }
            }
        };
    }
})();



(function (angular) {
    "use strict";
    angular.module('globalApp').service('adobeTracking', ['$rootScope', '$window', '$q', 'registry', '$route', function ($rootScope, $window, $q, registry, $route) {
        var _config = null;
        var _configured = false;
        var _trackUserID = 0;

        // we're getting out of the "good practices" here - dynamic script loading is always ugly stuff
        // no way around though for the various tracking methods
        function getScript(src) {
            var deferred = $q.defer();
            var s = $window.document.createElement('script');
            s.src = src;
            s.async = true;
            s.onreadystatechange = s.onload = function () {
                if ((!s.readyState || /loaded|complete/.test(s.readyState))) {
                    deferred.resolve();
                }
            };
            $window.document.body.appendChild(s);
            return deferred.promise;
        }

        function getScripts(array) {
            var deferred = $q.defer();

            var loaders = [];

            if (array) {
                angular.forEach(array, function (url) {
                    loaders.push({
                        url: url,
                        getScript: function () {
                            getScript(this.url).then(function () {
                                if (loaders.length == 1) {
                                    deferred.resolve();
                                }
                                else {
                                    // remove first item
                                    loaders.splice(0, 1);
                                    loaders[0].getScript();
                                }
                            });
                        }
                    });
                });
            }
            
            if (loaders.length > 0)
            {
                loaders[0].getScript();
            }
            else
            {
                deferred.resolve();
            }

            return deferred.promise;
        }

        function getProperties()
        {
            var result = {
                eVar2: _trackUserID === 0 ? "unrecognized" : "authenticated",
                channel: $rootScope.productVariables.ChannelID.toString(),
                eVar1: "D=g",
                prop1: "D=g",
                eVar4: _trackUserID.toString(),
                version: 0,
                appID: $rootScope.productVariables.ApplicationID,
                channelID: $rootScope.productVariables.ChannelID,
                countryID: $rootScope.productVariables.CountryID,
                pageName: getPageName(),
                events: ""
            };

            if ($rootScope.meta && $rootScope.meta.tracking && $rootScope.meta.tracking.pages) {
                for (var pageName in $rootScope.meta.tracking.pages) {
                    var page = $rootScope.meta.tracking.pages[pageName];
                    if (pageName.toLowerCase() === $route.current.loadedTemplateUrl.toLowerCase() && page.adobe) {
                        if (page.adobe.extras) {
                            for (var x in page.adobe.extras) {
                                var value = page.adobe.extras[x];
                                if (typeof value === "string")
                                {
                                    result[x] = value;
                                    continue;
                                }
                                if (typeof value === "function")
                                {
                                    result[x] = value();
                                    continue;
                                }
                                throw new Error('meta.tracking.pages[\'' + pageName + '\].adobe.extras.' + x + ' should be function or string');
                            }
                        }
                    }
                }
            }

            return result;
        }

        function copy(source, target)
        {
            for (var x in source) {
                target[x] = source[x];
            }
        }


        function afterScriptsLoaded(config) {
            _config = config;

            var trackUserID = $rootScope.registry.sessionStore.global.trackUserID;
            if (typeof trackUserID !== "undefined")
            {
                _trackUserID = trackUserID;
            }
            
            // at this point global tracking "engine" _m should be defined
            var _m = $window._m;
            var properties = getProperties();
            copy(properties, _m.ATM.s);
            //console.log('Firing adobe tracking impression (miniSPA init) ', properties.pageName, new Date());
            _m.ATM.s.t();

            $rootScope.$watch('registry.sessionStore.global.trackUserID', function (newValue) {
                if (typeof newValue !== "undefined")
                {
                    _trackUserID = newValue;
                    // copy(getProperties(trackUserID), _m.ATM.s);
                    // to track or not to track impression after login - that is the question
                }
            });

            // woo hoo we can track impressions now :)
            $rootScope.$on('$routeChangeSuccess', function () {
                var properties = getProperties();

                //console.log('Firing adobe tracking impression ($routeChangeSuccess) ', properties.pageName, new Date());
                copy(properties, _m.ATM.s);
                _m.ATM.s.t();
            });
        }

        function getPageName() {
            var pageName = 'undefined';
            if ($route.current && $route.current.loadedTemplateUrl)
            {
                pageName = $route.current.loadedTemplateUrl;
            }
            return _config.pageNamePrefix + pageName;
        }

        function beforeScriptsLoaded(config) {
            if (config.properites) {
                angular.forEach(config.properites, function (property) {
                    switch (property.name) {
                        case "accountName":
                            $window.DYNAMIC_S_ACCOUNT = property.value;
                            return;
                        case "currencyCode":
                            $window.DYNAMIC_S_CURRENCYCODE = property.value;
                            return;
                        case "pageNamePrefix":
                            config.pageNamePrefix = property.value;
                            return;
                    }
                });
            }
        }

        function configure(config) {
            var deferred = $q.defer();
            if (!_configured) {
                _configured = true;
                beforeScriptsLoaded(config);
                getScripts(config.trackingScriptUrls).then(function () {
                    afterScriptsLoaded(config);
                    deferred.resolve();
                });
            }
            else {
                deferred.resolve();
            }

            return deferred.promise;
        }

        return {
            name: "Adobe",
            configure: configure,
            track: function (event) {
                var properties = getProperties();
                if ($rootScope.meta && $rootScope.meta.tracking && $rootScope.meta.tracking.events)
                {
                    var myEvent = $rootScope.meta.tracking.events[event.name];
                    if (myEvent && myEvent.adobe)
                    {
                        for(var x in myEvent.adobe)
                        {
                            var value = myEvent.adobe[x];
                            if (typeof value === "string")
                            {
                                properties[x] = myEvent.adobe[x];
                                continue;
                            }
                            if (typeof value === "function")
                            {
                                properties[x] = value(event);
                                continue;
                            }
                            throw new Error('meta.tracking.events.' + event.name + '.adobe.' + x + ' should be function or string');
                        }
                    }
                }
                copy(properties, $window._m.ATM.s);
                console.log('Firing tracking event', properties.pageName, event.name, new Date());
                $window._m.ATM.s.t();
            }
        };
    }]);
})(angular);
(function () {
    'use strict';
    angular.module('globalApp').service('BrowserDetect', ['$window', function ($window) {
        return function () {
            return BrowserDetect();
        };

        function BrowserDetect() {
            return {
                init: function () {
                    return {
                        browser: this.searchString(this.dataBrowser) || "An unknown browser",
                        version: this.searchVersion(navigator.userAgent)
                            || this.searchVersion(navigator.appVersion)
                            || "an unknown version",
                        OS: this.searchString(this.dataOS) || "an unknown OS"
                    };
                },
                searchString: function (data) {
                    for (var i = 0; i < data.length; i++) {
                        var dataString = data[i].string;
                        var dataProp = data[i].prop;
                        this.versionSearchString = data[i].versionSearch || data[i].identity;
                        if (dataString) {
                            if (dataString.indexOf(data[i].subString) !== -1)
                            { return data[i].identity; }
                        }
                        else if (dataProp)
                        { return data[i].identity; }
                    }
                },
                searchVersion: function (dataString) {
                    var index = dataString.indexOf(this.versionSearchString);
                    if (index === -1) { return; }
                    return parseFloat(dataString.substring(index + this.versionSearchString.length + 1));
                },
                dataBrowser: [
                    {
                        string: navigator.userAgent,
                        subString: "Chrome",
                        identity: "Chrome"
                    },
                    {
                        string: navigator.userAgent,
                        subString: "OmniWeb",
                        versionSearch: "OmniWeb/",
                        identity: "OmniWeb"
                    },
                    {
                        string: navigator.vendor,
                        subString: "Apple",
                        identity: "Safari",
                        versionSearch: "Version"
                    },
                    {
                        prop: window.opera,
                        identity: "Opera",
                        versionSearch: "Version"
                    },
                    {
                        string: navigator.vendor,
                        subString: "iCab",
                        identity: "iCab"
                    },
                    {
                        string: navigator.vendor,
                        subString: "KDE",
                        identity: "Konqueror"
                    },
                    {
                        string: navigator.userAgent,
                        subString: "Firefox",
                        identity: "Firefox"
                    },
                    {
                        string: navigator.vendor,
                        subString: "Camino",
                        identity: "Camino"
                    },
                    {        // for newer Netscapes (6+)
                        string: navigator.userAgent,
                        subString: "Netscape",
                        identity: "Netscape"
                    },
                    {
                        string: navigator.userAgent,
                        subString: "MSIE",
                        identity: "Explorer",
                        versionSearch: "MSIE"
                    },
                    {
                        string: navigator.userAgent,
                        subString: "Gecko",
                        identity: "Mozilla",
                        versionSearch: "rv"
                    },
                    {         // for older Netscapes (4-)
                        string: navigator.userAgent,
                        subString: "Mozilla",
                        identity: "Netscape",
                        versionSearch: "Mozilla"
                    }
                ],
                dataOS: [
                    {
                        string: navigator.platform,
                        subString: "Win",
                        identity: "Windows"
                    },
                    {
                        string: navigator.platform,
                        subString: "Mac",
                        identity: "Mac"
                    },
                    {
                        string: navigator.userAgent,
                        subString: "iPhone",
                        identity: "iPhone/iPod"
                    },
                    {
                        string: navigator.platform,
                        subString: "Linux",
                        identity: "Linux"
                    }
                ]
            };
        }
    }]);
})();
(function () {
    angular.module('globalApp').service('BudgetCalculatorService', ['budgetCalculatorFactory', function (budgetCalculatorFactory) {
        return {
            tax: 15,
            getCalculation: getCalculation
        }

        function getCalculation(utilities, misc) {
            var total = Number(calculateAll(utilities)) + Number(calculateAll(misc));
            var annual = Math.round(total * 12);
            var rawTax = Math.round(annual * (this.tax / 100));
            var taxed = annual + rawTax;
            var hourly = Math.round(taxed / 2080);

            return {
                totalMonthlyExpense: currencyFormat(total),
                totalAnnualExpense: currencyFormat(annual),
                totalAnnualTax: currencyFormat(rawTax),
                grossTargetSalary: currencyFormat(taxed),
                netTargetSalary: currencyFormat(annual),
                targetHourlyRate: currencyFormat(hourly)
            }
        }

        function calculateAll(objs) {
            var temp = 0;
            for (var key in objs) {
                if (objs[key].hasOwnProperty('amount')) {
                    if (objs[key].amount !== NaN) {
                        temp += Number(objs[key].amount);
                    }
                }
            }
            return temp.toFixed(2) || 0;
        }

        function currencyFormat(number) {
            var decimalplaces = 2;
            var decimalcharacter = ".";
            var thousandseparater = ",";
            number = parseFloat(number);
            var sign = number < 0 ? "-" : "";
            var formatted = new String(number.toFixed(decimalplaces));
            if (decimalcharacter.length && decimalcharacter != ".") { formatted = formatted.replace(/\./, decimalcharacter); }
            var integer = "";
            var fraction = "";
            var strnumber = new String(formatted);
            var dotpos = decimalcharacter.length ? strnumber.indexOf(decimalcharacter) : -1;
            if (dotpos > -1) {
                if (dotpos) { integer = strnumber.substr(0, dotpos); }
                fraction = strnumber.substr(dotpos + 1);
            }
            else { integer = strnumber; }
            if (integer) { integer = String(Math.abs(integer)); }
            while (fraction.length < decimalplaces) { fraction += "0"; }
            var temparray = new Array();
            while (integer.length > 3) {
                temparray.unshift(integer.substr(-3));
                integer = integer.substr(0, integer.length - 3);
            }
            temparray.unshift(integer);
            integer = temparray.join(thousandseparater);
            return sign + integer + decimalcharacter + fraction;
        }
    }]);
})();

(function () {
    'use strict';

    angular.module('globalApp').service('cachedResource', ['$resource', '$rootScope', 'cacheService', cachedResourceFactory]);

    function cachedResourceFactory($resource, $rootScope, cacheService) {

        return function (url, paramDefaults, actions, options) {

            var cacheType = $rootScope.productVariables.caching.cacheTypesEnum.httpPrivateCache;
            var cacheProvider = cacheService.provider(cacheType);
            var cache = cacheProvider.cache;

            var invalidateCacheInterceptor = {
                response: function (response) {
                    cacheProvider.remove(response.config.url);
                    console.log('cache removed', response.config.url);

                    //if item has been modified, then invalidate the parent item list as well
                    if (response.config.method === 'PUT' || response.config.method === 'DELETE') {
                        var parentKey = response.config.url.substring(0, response.config.url.lastIndexOf('/'));
                        cacheProvider.remove(parentKey);
                    }

                    //immediatelly cache the newly created item
                    if (response.config.method === 'POST') {
                        var cacheKey = response.headers().location;
                        if (cacheKey) {
                            cacheProvider.addOrUpdate(cacheKey, response.data);
                        }                        
                    }

                    return response;
                }
            };

            actions = angular.merge({}, {}, actions, {
                'get': { method: 'GET', cache: cache },
                'query': { method: 'GET', cache: cache, isArray: true },
                'save': { method: 'POST', interceptor: invalidateCacheInterceptor },
                'update': { method: 'PUT', interceptor: invalidateCacheInterceptor },
                'remove': { method: 'DELETE', interceptor: invalidateCacheInterceptor },
                'delete': { method: 'DELETE', interceptor: invalidateCacheInterceptor }
            });

            return $resource(url, paramDefaults, actions, options);
        };        

    };

})();
(function () {
    'use strict';

    angular.module("globalApp").service("cacheService", ['CacheFactory', '_', '$rootScope', cacheService]);    

// ReSharper disable once InconsistentNaming
    function cacheService(CacheFactory, _, $rootScope) {

        //$rootScope.productVariables.cacheTypes = {
        //    'shared': 0, //shared with manual approach; e.g. messages, channel configs
        //    'httpShared': 1, //shared with automatic approach (http cache); cached by url; e.g. lookups
        //    'private': 2, //private with manual approach; specific to given session or user; e.g. login info
        //    'httpPrivate': 3 //private with automatic approach (http cache); e.g. cover letters, documents
        //};

        //abstraction around the underlying caching factory(ies) providing unified access to the cache provider API
        var cacheProvider = function (cacheFactory) {
            var provider = {
                cache: cacheFactory, //provide access to the underlying cache factory
                get: get, //get cached item 
                addOrUpdate: addOrUpdate, //add or updates cache
                remove: remove, //remove cached item
                clearAll: clearAll //remove all cached item 
            };

            var nullProvider = {
                cache: null,
                get: function() { return null; }, 
                addOrUpdate: function() {}, 
                remove: function () {}, 
                clearAll: function () {}
            };

            function get(cacheKey) {                
                return cacheFactory.get(cacheKey);
            };

            function remove(cacheKey) {
                return cacheFactory.remove(cacheKey);
            };

            function addOrUpdate(cacheKey, cacheValue) {
                if (get(cacheKey)) {
                    remove(cacheKey);
                }
                return cacheFactory.put(cacheKey, cacheValue);
            };            

            function clearAll() {
                return cacheFactory.removeAll();
            };

            return (null === cacheFactory) ? nullProvider : provider;
        }

        //takes care of creating/providing access to the caching factory(ies)
        var cacheProviderFactory = function (cacheType) {

            //init the provider based on the $rootScope.productVariables.cacheTypes settings
            var cache = _.find($rootScope.productVariables.caching.cacheTypesDef, function (o) {
                return o.cacheType === cacheType;
            });

            if (!cache || cache.enabled === "false") return cacheProvider(null);

            var cacheFactory = CacheFactory.get(cacheType) || CacheFactory(cacheType, cache.initOptions);

            return cacheProvider(cacheFactory);
        }        

        //public accessor
        this.provider = function (cacheType) {
            return cacheProviderFactory(cacheType);
        }                        
    }

})();
(function(angular) {
    angular.module("globalApp").service("contextService", ["registry", function(registry) {
        return {
            init: function () {
                registry.set("global", "context", {
                    "ChannelID": 10338,
                    "CountryID": 164,
                    "ApplicationID": "Lexus",
                    "ChannelAlias": "LEXUSDEMO",
                    "ChannelAliases": ["CORE", "CORE-EN", "US-EN", "CS-USEN", "LEXUSCORE", "LEXUSDEMO"],
                    "EnvironmentType": "Development",
                    "Version": "1.0.0.0",
                    "UIConfiguration": "Debug",
                    "cdnUrl": "https://core.ui.lexus.monster.com/cdn-release/unstable",
                    "templateUrl": "https://core.ui.lexus.monster.com/uiCore/templates/"
                }, "localStorage");
            }
        };
    }]);
})(angular);

(function (angular) {
    "use strict";
    angular.module('globalApp').service('coreUiTemplateService', function () {
        // empty on purpose; real coreUiTemplateService will be created via gulp
        return { init: function () { } };
    });
})(angular);
(function (angular) {
    'use strict';
    // this runs based on the "dataSource" value in the meta table, it will get the values and overwrite the current entrys in the meta table
    angular.module('globalApp').service("dataSourceService", [function () {
        var providers = {};

        return {
            addProvider: function(type, fn) {
                if (typeof fn !== "function")
                {
                    throw new Error("fn should be function.");
                }
                providers[type] = fn;
            },
            dataSource: function (type, newValue, newValue2) {
                //console.log(type + ' ' + newValue + ' ' + newValue2);
                var provider = providers[type];
                if (typeof provider === "undefined")
                {
                    throw new Error("Unknown dataSource provider - " + type);
                }

                return provider(newValue, newValue2);
            }
        };
    }]);
})(angular);
(function (angular) {
    'use strict';
    angular.module('globalApp').service('delayedSave', ['$rootScope', '$window', 'registry', '$q', service]);

    function service($rootScope, $window, registry, $q) {
        function compareNow(dateTime) {
            var momentA = moment(new Date(dateTime)).utc();
            var momentB = moment(new Date()).utc();
            if (momentA > momentB) return true;
            else if (momentA < momentB) return false;
            else return false;
        }

        var service = this;
        service.persistors = {};
        service.addPersistor = function (name, persistFunction) {
            service.persistors[name] = persistFunction;
        };

        service.init = function () {
            var promises = [];
            if ($rootScope.registry && $rootScope.registry.sessionStore && $rootScope.registry.sessionStore.delayedSave) {
                var delayedSaveItems = $rootScope.registry.sessionStore.delayedSave;
                for (var key in delayedSaveItems) {
                    if (delayedSaveItems.hasOwnProperty(key)) {
                        var promise = createSavePromise(key, delayedSaveItems[key]);
                        if (promise !== null) {
                            promises.push(promise);
                        }
                    }
                }
            }
            var local = registry.getAll('localStorage');
            if (local && local.delayedSave) {
                var delayedSaveItems = local.delayedSave;
                for (var key in delayedSaveItems) {
                    if (delayedSaveItems.hasOwnProperty(key)) {
                        if (compareNow(delayedSaveItems[key].expireOn)) {
                            delete delayedSaveItems[key].expireOn;
                            var promise = createSavePromise(key, delayedSaveItems[key]);
                            if (promise !== null) {
                                promises.push(promise);
                            }
                        } else {
                            delete delayedSaveItems[key];
                        }
                    }
                }
            }
            return $q.all(promises);
        };

        function createSavePromise(itemForSaveName, itemForSaveObj) {
            if (typeof service.persistors[itemForSaveName] !== undefined) {
                var persistFunction = service.persistors[itemForSaveName];
                return persistFunction(itemForSaveObj).then(function (data) {
                    registry.removeDelayedSave(itemForSaveName);
                });
            }
            return null;
        }
    }
})(angular);
//  pre-resolve all Layout Configs : 
//
//
//
(function () {
    'use strict';
    angular.module('globalApp').service('errorDispatch', [runFunction]);
    function runFunction() {
        //                                                _______________________
        //_______________________________________________/   private functions   \_____________________
        //

        //                                                ____________________
        //_______________________________________________/    ErrorDispatch   \_____________________
        //

        return {
            init: function () {
                //console.log("ErrorDispatch has initilized");
            },
            alertError: function (obj) {
                console.log('Communication - ERROR: ' + obj.config.url);



            },
        }
    }


})();



//
//  this is code that I hope to make use of,  it allows for an error "catch all" but also allows for a bypass of the catch. 
//  Right now it does not play well with the other  "$httpProvider.interceptors"  that is being used for batching of requests.


//(function () {
//    var HEADER_NAME = 'MyApp-Handle-Errors-Generically';
//    var specificallyHandleInProgress = false;

//    angular.module('globalApp').factory('RequestsErrorHandler', ['$q', '$rootScope', function ($q) {
//        return {
//            // --- The user's API for claiming responsiblity for requests ---
//            specificallyHandled: function (specificallyHandledBlock) {
//                specificallyHandleInProgress = true;
//                try {
//                    return specificallyHandledBlock();
//                } finally {
//                    specificallyHandleInProgress = false;
//                }
//            },

//            // --- Response interceptor for handling errors generically ---
//            responseError: function (rejection) {
//                var shouldHandle = (rejection && rejection.config && rejection.config.headers
//                    && rejection.config.headers[HEADER_NAME]);

//                if (shouldHandle) {
//                    // --- Your generic error handling goes here ---

//                    console.log("RequestsErrorHandler - Triggered");
//                    console.log(rejection.config.url);
//                    console.log(rejection.config);

//                    //if (!$rootScope.topErrorList) { $rootScope.topErrorList = [] };
//                    //$rootScope.topErrorList.push(rejection.config.url);


//                }

//                return $q.reject(rejection);
//            }
//        };
//    }]);

//    angular.module('globalApp').config(['$provide', '$httpProvider', function ($provide, $httpProvider) {
//        $httpProvider.interceptors.push('RequestsErrorHandler');

//        // --- Decorate $http to add a special header by default ---

//        function addHeaderToConfig(config) {
//            config = config || {};
//            config.headers = config.headers || {};

//            // Add the header unless user asked to handle errors himself
//            if (!specificallyHandleInProgress) {
//                config.headers[HEADER_NAME] = true;
//            }

//            return config;
//        }

//        // The rest here is mostly boilerplate needed to decorate $http safely
//        $provide.decorator('$http', ['$delegate', function ($delegate) {
//            function decorateRegularCall(method) {
//                return function (url, config) {
//                    return $delegate[method](url, addHeaderToConfig(config));
//                };
//            }

//            function decorateDataCall(method) {
//                return function (url, data, config) {
//                    return $delegate[method](url, data, addHeaderToConfig(config));
//                };
//            }

//            function copyNotOverriddenAttributes(newHttp) {
//                for (var attr in $delegate) {
//                    if (!newHttp.hasOwnProperty(attr)) {
//                        if (typeof ($delegate[attr]) === 'function') {
//                            newHttp[attr] = function () {
//                                return $delegate[attr].apply($delegate, arguments);
//                            };
//                        } else {
//                            newHttp[attr] = $delegate[attr];
//                        }
//                    }
//                }
//            }

//            var newHttp = function (config) {
//                return $delegate(addHeaderToConfig(config));
//            };

//            newHttp.get = decorateRegularCall('get');
//            newHttp.delete = decorateRegularCall('delete');
//            newHttp.head = decorateRegularCall('head');
//            newHttp.jsonp = decorateRegularCall('jsonp');
//            newHttp.post = decorateDataCall('post');
//            newHttp.put = decorateDataCall('put');

//            copyNotOverriddenAttributes(newHttp);

//            return newHttp;
//        }]);
//    }]);

//})();



(function () {
    'use strict';
    angular.module('globalApp').service('gotoAnchor', ['$rootScope', '$location', '$anchorScroll', runFunction]);
    function runFunction($rootScope, $location, $anchorScroll) {
        return {
            init: function () {
                $rootScope.gotoAnchor = function (id) {
                    if ($location.hash() !== id) {
                        // set the $location.hash to `newHash` and
                        // $anchorScroll will automatically scroll to it
                        $location.hash(id);
                    } else {
                        // call $anchorScroll() explicitly,
                        // since $location.hash hasn't changed
                        $anchorScroll();
                    }
                };
            }
        }
    }

})();

(function () {
    'use strict';
    angular.module("globalApp").service("logInWatcher", ['$rootScope', '$window', 'registry', 'delayedSave', service]);
    function service($rootScope, $window, registry, delayedSave) {
        return {
            init: function () {
                $rootScope.logInWatcher = function (initFunction, onLogout) {
                    if ($rootScope.isAuthenticated) {
                        callInitFunction();
                    }

                    function callInitFunction()
                    {
                        if (initFunction)
                        {
                            initFunction();
                        }
                    }

                    $rootScope.$watch('isAuthenticated', function (newValue, oldValue) {
                        if (oldValue === true && newValue === false) {
                            // they clicked the log out button
                            registry.purge();

                            //pass if you like to do stuff on logout
                            if (onLogout) {
                                onLogout();
                            }
                            //$window.location.reload();  // or a redirect
                            //console.log('logging off');
                            window.location.assign('/home');
                        }
                        if (newValue === true && oldValue === false) {
                            delayedSave.init().then(callInitFunction);
                        }
                    });
                };
            }
        };
    }
})();




(function () {
    'use strict';

    angular.module('globalApp').service('lookUpGlobalJson', ['$rootScope', serviceFunction]);
    function serviceFunction($rootScope) {
        return {
            init: function () {
                // this is the global channel look-up function for the template system
                $rootScope.cfg = function (id) {
                    id = id.split(".");
                    var v = "";
                    var value = $rootScope.configLayout;
                    for (var x in id) {
                        value = value[id[x]];
                    }
                    
                    if (value) {
                        value = value.lookUpConfig.value;
                        return value
                    }

                    console.log("config '" +id+ "' not Resolved!");
                    return false;
                }

                //not really need anymore???
                $rootScope.getStorage = function (name) {
                    return $rootScope.registry.sessionStore.delayedSave[name];
                }

                // this is the global message look up function for the template system
                $rootScope.msg = function (id) {
                    //return $rootScope.meta.messages[id].lookUpMsg.value;

                    for (var x in $rootScope.serverMessagesObj) {
                        if ($rootScope.serverMessagesObj[x].id == id) {
                            return $rootScope.serverMessagesObj[x].text;
                        }
                    }
                }


                // note: this should be removed, the new function is cfg()
                $rootScope.getLayoutConfig = function (theOne) {
                    return $rootScope.configLayout[theOne].lookUpConfig.value;
                }

                // note: this should be removed, the new function is cfg()
                // this is the global Config look up function for the template system
                $rootScope.getConfig = function (id) {
                    return findConfig(id, $rootScope.configLayout);
                }

            }
        }
    }

})();

(function () {
    'use strict';
    angular.module("globalApp").service('menuCreator', ['$location', 'utilityService', service]);

    function service($location, utilityService) {
        this.createBreadCrumbs = function (menuConfig, navMasterItems) {
            if (menuConfig && navMasterItems) {
                var path = $location.absUrl().substr($location.protocol().length + $location.host().length + 3);
                var pageAlias;
                for (var i = 0; i < navMasterItems.length; i++) {
                    var item = navMasterItems[i];
                    if (item.url && path.startsWith(item.url)) {
                        pageAlias = item.value;
                        break;
                    }
                }
                if (pageAlias) {
                    var stack = [];
                    utilityService.forEach(menuConfig, function (value, nodes) {
                        if (value.masterListItem && value.masterListItem === pageAlias) {
                            stack = nodes.slice();
                            stack.push(value);
                        }
                    });

                    // always include home
                    var items = [{ display: navMasterItems[0].display.lookUpMsg, url: '/#/' }];
                    //var items = [];

                    for (var j = 0; j < stack.length; j++) {
                        if (stack[j].masterListItem) {
                            for (var i = 0; i < navMasterItems.length; i++) {
                                var navMasterItem = navMasterItems[i];
                                if (navMasterItem.value === stack[j].masterListItem) {
                                    var item = { display: navMasterItem.display.lookUpMsg };
                                    if (navMasterItem.url !== '/#/') {
                                        item.url = navMasterItem.url;
                                    }
                                    items.push(item);
                                    break;
                                }
                            }
                        }
                    }
                    //if (items.length > 1) {
                    //    items[items.length - 1].url = null;
                    //}
                    return items;
                }
            }
            return [];
        };

        this.create = function (menuConfig, masterItemList) {

            var menuTarget = {};
            for (var b in menuConfig) {
                var display = "";
                var url = "";
                var icon = "";
                var queryString = "";

                var bucketItem = menuConfig[b].bucket.masterListItem;

                for (var item in masterItemList) {
                    var masterItem = masterItemList[item];

                    if (bucketItem == masterItem.value) {
                        display = masterItem.display.lookUpMsg.value;
                        url = masterItem.url;
                        if (bucketItem == "icon") {
                            icon = menuConfig[b].bucket.icon;
                            url = menuConfig[b].bucket.url;
                        }
                        if (bucketItem == "externalUrl") {
                            url = menuConfig[b].bucket.url;
                            display = menuConfig[b].bucket.display;
                        }
                        if (bucketItem == "CmsPage") {
                            url = url + menuConfig[b].bucket.queryString;
                            display = menuConfig[b].bucket.display;
                        }
                    }
                }



                if (menuConfig[b].bucket.items) {
                    menuTarget[b] = { display: display, icon: icon, queryString: queryString };


                    for (var child = 0; child < menuConfig[b].bucket.items.length; child++) {
                        var displayChild = "";
                        var urlChild = "";
                        var iconChild = "";
                        var queryStringChild = "";
                        var bucketItemChildChild = menuConfig[b].bucket.items[child].masterListItem;

                        for (var item1 in masterItemList) {
                            var masterItem = masterItemList[item1];
                            if (bucketItemChildChild == masterItem.value) {
                                displayChild = masterItem.display.lookUpMsg.value;
                                urlChild = masterItem.url;
                                if (bucketItemChildChild == "icon") {
                                    displayChild = "";
                                    iconChild = menuConfig[b].bucket.items[child].display;
                                    urlChild = menuConfig[b].bucket.items[child].url;
                                }
                                if (bucketItemChildChild == "externalUrl") {
                                    urlChild = menuConfig[b].bucket.items[child].url;
                                    displayChild = menuConfig[b].bucket.items[child].display;
                                }
                                if (bucketItemChildChild == "cmsPage") {
                                    urlChild = urlChild + menuConfig[b].bucket.items[child].queryString;
                                    displayChild = menuConfig[b].bucket.items[child].display;
                                }
                            }
                        }
                        if (displayChild != "") {
                            menuTarget[b][child] = { display: displayChild, url: urlChild, icon: iconChild, queryString: queryStringChild };
                        }
                    }

                }
                else {

                    menuTarget[b] = { display: display, url: url, icon: icon, queryString: queryString };

                }

            }
            return menuTarget;
        }
    }
})();
//  pre-resolve all Layout Configs : 
//
//
//
(function () {
    'use strict';
    angular.module('globalApp').service('resolveLayoutConfigs', ['$rootScope', '$q', 'channelConfig', runFunction]);
    function runFunction($rootScope, $q, channelConfig) {

        //                                                _______________________
        //_______________________________________________/   private functions   \_____________________
        //
        function createList(j, list) {
            if (list == undefined) { var list = [] };
            for (var x in j) {
                if (typeof j[x] === 'object') {
                    if (x === 'lookUpConfig') {
                        var id = j[x].serverId;
                        var itsNew = true;
                        for (var q in list) {
                            if (id == list[q]) { itsNew = false; }
                        }
                        if ((itsNew === true) && (id != "")) { list.push(id); }
                    }
                    else { createList(j[x], list) }
                }
            }
            return (list);
        }


        function getData(list) {
            var deferred = $q.defer();
            if ((list !== undefined) && (list.length > 0)) {
                channelConfig.post(list).$promise.then(function (data) {
                    return deferred.resolve(data);
                });
            } else {
                return deferred.resolve($rootScope.configLayout);
            }
            return deferred.promise;
        }



        function placeData(j, returnedData) {
            for (var x in j) {
                if (typeof j[x] === 'object') {
                    if (x === 'lookUpConfig') {
                        var id = j[x].serverId;
                        var value = j[x].value;
                        if (id) {
                            var cfg = lookup(id, returnedData);
                            if (cfg) {
                                j[x].value = cfg;
                            }
                        }
                    }
                    else { placeData(j[x], returnedData) }
                }
            }
        }


        function lookup(alias, returnedData) {
            var j = returnedData;
            if (j) {
                for (var r = 0; r < j.length; r++) {
                    if (j[r].channelConfigAlias == alias) {
                        if (j[r].channelConfigValue) {
                            return (j[r].channelConfigValue);
                        }
                    }
                }
            }
            return "Not Found";
        }


        //                                                _____________________________
        //_______________________________________________/  layout Configs pre-resolve \_____________________
        //

        return {
            init: function () {
                var deferred = $q.defer();
                getData(createList($rootScope.configLayout)).then(function (results) {
                    placeData($rootScope.configLayout, results);
                    return deferred.resolve()
                });
                return deferred.promise;
            },
        }
    }

})();

//  pre-resolve all Layout Configs : 
//
//  meta Configs
//
(function () {
    'use strict';
    angular.module('globalApp').service('resolveMetaConfigs', ['$rootScope', '$q', 'channelConfig', runFunction]);
    function runFunction($rootScope, $q, channelConfig) {

        //                                                _______________________
        //_______________________________________________/   private functions   \_____________________
        //
        function createList(j, list) {
            if (list == undefined) { var list = [] };
            for (var x in j) {
                if (typeof j[x] === 'object') {
                    if (x === 'lookUpConfig') {
                        var id = j[x].serverId;
                        var itsNew = true;
                        for (var q in list) {
                            if (id == list[q]) { itsNew = false; }
                        }
                        if ((itsNew === true) && (id != "")) { list.push(id); }
                    }
                    else { createList(j[x], list) }
                }
            }
            return (list);
        }


        function getData(configs) {
            var deferred = $q.defer();

            if ((configs.length > 0) && (configs !== undefined)) {
                channelConfig.post(configs).$promise.then(function (data) {
                    return deferred.resolve(data);
                });
            } else {
                return deferred.resolve();
            }

            return deferred.promise;
        }


        function placeData(j, returnedData) {
            for (var x in j) {
                if (typeof j[x] === 'object') {
                    if (x === 'lookUpConfig') {
                        var id = j[x].serverId;
                        var value = j[x].value;
                        if (id) {
                            var cfg = lookup(id, returnedData);
                            if (cfg) {
                                j[x].value = cfg;
                            }
                        }
                    }
                    else { placeData(j[x], returnedData) }
                }
            }
        }


        function lookup(alias, returnedData) {
            var j = returnedData;
            if (j) {
                for (var r = 0; r < j.length; r++) {
                    if (j[r].channelConfigAlias == alias) {
                        if (j[r].channelConfigValue) {
                            return (j[r].channelConfigValue);
                        }
                    }
                }
            }
            return "Not Found";
        }





        // this is the second stage,  it takes the values from the metaConfig and places the values in the same tree spot in the meta object.
        // this function recurses threw the metaConfig, collects the path to the endpoint in an array (path), and sends the path and value to the setJsonValue function.
        function superemposeConfigsAndMeta(j, targetMeta, path) {
            if (path == undefined) { path = [] };
            for (var x in j) {
                if (typeof j[x] === 'object') {
                    if (x === 'lookUpConfig') {
                        var id = j[x].serverId;
                        var value = j[x].value;
                        setJsonValue($rootScope.meta, path, value);
                    }
                    else {
                        path.push(x);
                        superemposeConfigsAndMeta(j[x], targetMeta, path);
                    }
                }
            }
        }


        // find a node in a json object based on an array (used as a map), and set the end point value
        function setJsonValue(j, path, value) {
            var n = 0;
            for (n in j) {
                //console.log(path);
                if (path.length > 0) {
                    if (n == path[0]) {
                        path.shift(); // drop the first array eliment becase its been found as a node
                        if (path.length == 0) {  // correct endpoint found
                            j[n] = value;
                        }
                        if (typeof j[n] == 'object') {  //  its an object so dig deeper
                            setJsonValue(j[n], path, value);
                        }
                        break;  // for effecency stop the loop if the node matches.
                    }
                }
            }
        }





        //                                                ____________________________
        //_______________________________________________/  Meta Configs pre-resolve  \_____________________
        //

        return {
            init: function () {
                var deferred = $q.defer();
                var list = createList($rootScope.configMeta);

                if (list.length > 0) {
                    getData(list).then(function (results) {
                        placeData($rootScope.configMeta, results);
                        //  note: this still needs work,  it needs to now update $rootScope.meta with the values from $rootScope.configMeta
                        superemposeConfigsAndMeta($rootScope.configMeta, $rootScope.meta);

                        return deferred.resolve()
                    });
                } else {
                    return deferred.resolve()
                }


                return deferred.promise;
            },

        }
    }

})();















//// overwrites the meta variables with the returned configs
//function placeData(config, nodeTree) {
//    if (!nodeTree) { nodeTree = []; }
//    var x = 0;
//    for (x in config) {
//        if (typeof config[x] === 'object') {
//            nodeTree.push(x);
//            if (x === 'lookUpConfig') {
//                var id = config[x].serverId;
//                var value = config[x].value;

//                if (value) {
//                    nodeTree.pop();  // remove the last node ('lookUpConfig ')
//                    setJsonValue($rootScope.meta, nodeTree, value);
//                }

//            }
//            placeData(config[x], nodeTree);
//        }
//    }
//}



//// find a node in a json object based on an array (used as a map), and set the end point value
//function setJsonValue(j, path, value) {
//    var n = 0;
//    for (n in j) {
//        //console.log(path);
//        if (path.length > 0) {
//            if (n == path[0]) {
//                path.shift(); // drop the first array eliment becase its been found as a node
//                if (path.length == 0) {  // correct endpoint found
//                    j[n] = value;
//                }
//                if (typeof j[n] == 'object') {  //  its an object so dig deeper
//                    setJsonValue(j[n], path, value);
//                }
//                break;  // for effecency stop the loop if the node matches.
//            }
//        }
//    }
//}




//  pre-resolve all Layout Configs : 
//
//
//
(function () {
    'use strict';
    angular.module('globalApp').service('resolveDataSource', ['$rootScope', '$q', 'dataSourceService', runFunction]);
    function runFunction($rootScope, $q, dataSourceService) {

        //                                                _______________________
        //_______________________________________________/   private functions   \_____________________
        //
        function createList(j, list) {
            //var deferred = $q.defer();

            if (list == undefined) {
                var list = new Array(1);
                list[0] = [];
                list[1] = [];
                list[2] = [];
                list[3] = [];

            };
            for (var x in j) {
                if (typeof j[x] === 'object') {
                    if (x === 'dataSource') {
                        var name = j[x].name;
                        var value = j[x].value;
                        var value2 = j[x].value2;
                        var itsNew = true;
                        for (var q in list) {
                            if ((name == list[q][0]) && (value == list[q][1])) {
                                itsNew = false;
                            }
                        }
                        if ((itsNew === true) && (name != "")) {
                            list[0].push(name);
                            list[1].push(value);
                            list[2].push(value2);
                            list[3].push(j);
                        }
                    }
                    else {
                        createList(j[x], list);
                    }
                }
            }

            return list;
            //return deferred.promise;
        }


        function getData(list) {
            var deferred = $q.defer();

            var fullList = [];
            for (var x=0 ; x<list[0].length; x++) {
                var serviceName = list[0][x];
                var variable = list[1][x];
                var variable2 = list[2][x];
                var locationInTree = list[3][x];

                fullList.push(promiseData(serviceName, variable, variable2, locationInTree));

            }

            $q.all(fullList).then(function (results) {
                return deferred.resolve();
            });

            return deferred.promise;
        }


        function promiseData(serviceName, variable, variable2, locationInTree) {
            var deferred = $q.defer();
            dataSourceService.dataSource(serviceName, variable, variable2).then(function (results) {
                locationInTree.items = results;
                return deferred.resolve();
            });
            return deferred.promise;
        }




        //                                                _____________________________
        //_______________________________________________/  layout Configs pre-resolve \_____________________
        //

        return {
            init: function () {
                var deferred = $q.defer();

                var list = createList($rootScope.meta);
                getData(list).then(function (results) {
                    return deferred.resolve();
                });

                return deferred.promise;
            },
        }
    }

})();

//  pre-resolve all messages : 
//     this creates a list of messages in the meta data for the page, it then gets the messages from the server, and then adds the new data to the meta mesages
//     example : 
//       metaBefore: { lookUpMsg: { id: 364081, text: 'Create Account' } }
//       metaAfter:  { lookUpMsg: { id: 364081, text: 'Create Account' , value: 'Create Account from service' } }
//
(function () {
    'use strict';
    angular.module('globalApp').service('resolveMetaMessages', ['$rootScope', '$q', 'getMessage', runFunction]);
    function runFunction($rootScope, $q, getMessage) {

        //                                                _______________________
        //_______________________________________________/   private functions   \_____________________
        //
        function createList(j, list) {
            if (list == undefined) { var list = [] };
            for (var x in j) {
                if (typeof j[x] === 'object') {
                    if (x === 'lookUpMsg') {
                        var id = j[x].id;
                        var itsNew = true;
                        if (id > 0) {
                            for (var q in list) { if (id == list[q]) { itsNew = false; } }
                            if (itsNew === true) { list.push(id); }
                        }
                    }
                    else { createList(j[x], list) }
                }
            }
            return (list);
        }



        function getData(list) {
            var deferred = $q.defer();
            if (list) {
                var formattedList = [];
                for (var x in list) {
                    formattedList.push('{"id":' + list[x] + '}');
                }
                formattedList = '{"messages":[' + formattedList + ']}';

                getMessage.post(formattedList).$promise.then(function (data) {
                    return deferred.resolve(data.messages)
                });
            }
            return deferred.promise;
        }



        function placeData(j, returnedData) {
            for (var x in j) {
                if (typeof j[x] === 'object') {
                    if (x === 'lookUpMsg') {
                        var id = j[x].id;
                        var text = j[x].text;
                        var msg = lookup(id, returnedData);
                        // if you want message defaults to come from "text:" then add it below
                        if (msg !== undefined) { j[x].value = msg; } else { j[x].value = text; }
                    }
                    else { placeData(j[x], returnedData) }
                }
            }
            return;
        }


        function lookup(id, j) {
            if (j) {
                var r = 0;
                for (r = 0; r < j.length; r++) {
                    if (j[r].id == id) {
                        if (j[r].text) {
                            return (j[r].text);
                        }
                    }
                }
            }
        }

        
        //                                                _______________________
        //_______________________________________________/  messages pre-resolve \_____________________
        //

        return {
            init: function () {
                var deferred = $q.defer();
                getData(createList($rootScope.meta)).then(function (results) {



                    // this is for the debug [M] function
                    $rootScope.serverMessagesObj = results;
                    placeData($rootScope.meta, results)

                    return deferred.resolve($rootScope.meta)
                });
                return deferred.promise;
            },

        }
    }

})();












////below is working code to make the messages "pile up" from page to page, this will cache the messages as they are discovered.
////I have disabled it for now, because we are still creating the product, and this optimization makes it vary difficult to add and or debug new functions.

//var messageCacheType = $rootScope.productVariables.caching.cacheTypesEnum.sharedCache;
//// get data for message Ids in meta 
//function getMessageData(messages) {
//    var deferred = $q.defer();
//    if (messages) {

//        //get cached messages            
//        var cachedMessages = cacheService.provider(messageCacheType).get(getMessagesCacheKey());

//        //find messages not in cache            
//        var msgs = _.map(messages, function (value) { return { 'id': value } });
//        var notCachedIds = _.differenceBy(msgs, cachedMessages, 'id');

//        //if everything is in cache, resolve promise here
//        if (!notCachedIds || notCachedIds.length < 1) {
//            $rootScope.serverMessagesObj = cachedMessages;
//            appendList($rootScope.meta);
//            return deferred.resolve(cachedMessages);
//        }

//        var formattedList = { 'messages': notCachedIds };
//        getMessage.post(formattedList).$promise.then(function (data) {

//            //merge resultset with cached items
//            var messageCacheKey = getMessagesCacheKey();
//            var cacheProvider = cacheService.provider(messageCacheType);
//            var cachedItems = cacheProvider.get(messageCacheKey);

//            //TODO - find out why extend doesn't work here
//            //var allMessages = _.extend(cachedMessages, data.messages);
//            var allMessages = cachedItems || [];
//            for (var i = 0; i < data.messages.length; i++) {
//                allMessages.push(data.messages[i]);
//            }

//            //cache the merged items
//            cacheProvider.addOrUpdate(messageCacheKey, allMessages);

//            //make the items accessible via meta system
//            $rootScope.serverMessagesObj = allMessages;
//            appendList($rootScope.meta);
//            return deferred.resolve($rootScope.meta);
//        });

//    }

//    return deferred.promise;
//}



//function getMessagesCacheKey() {
//    var channelId = $rootScope.productVariables.ChannelID;
//    return 'messages_' + channelId;
//}



(function (angular) {
    'use strict';
    angular.module('globalApp').service('resolveTracking', ['$rootScope', '$q', 'trackFactory', 'registry', 'trackService', runFunction]);

    function runFunction($rootScope, $q, trackFactory, registry, trackService) {
        return {
            init: function () {
                var deferred = $q.defer();
                var configs = registry.get('global', 'trackingConfigs', 'sessionStorage');
                if (configs) {
                    trackService.configure(configs);
                    return deferred.resolve($rootScope.trackingConfigs);
                }
                else {
                    trackFactory.getTrackingConfigs().$promise.then(function (results) {
                        registry.set('global', 'trackingConfigs', results, 'sessionStorage');
                        trackService.configure(results);
                        return deferred.resolve($rootScope.trackingConfigs);
                    });
                    return deferred.promise;
                }
            }
        };
    }
})(angular);

(function () {
    'use strict';
    angular.module("globalApp").service("productVariables", ['$rootScope', 'registry' ,service]);

    function service($rootScope, registry) {
        return {
            init: function () {
                // load the registry
                //registry.set('token', '123', 'sessionStorage');
                //registry.set('ApplicationID', contextService.context.ApplicationID, 'sessionStorage');
                //registry.set('ChannelAlias', contextService.context.ChannelAlias, 'sessionStorage');
                //registry.set('ChannelID', contextService.context.ChannelID, 'sessionStorage');
                //registry.set('EnvironmentType', contextService.context.EnvironmentType, 'sessionStorage');
                //registry.set('serviceHost', 'services.lexus.monster.com', 'sessionStorage');
                //registry.set('rootUrl', 'https://' + $rootScope.registry.sessionStore.serviceHost, 'sessionStorage');
                //registry.set('standardMask', { usPhone: "(999) 999-9999", ssn: "999-99-9999", usDate: '99/99/9999' }, 'sessionStorage');
                //registry.set('constants', { UBF_CRL_DEFAULT_YES: '2008', UBF_CRL_DEFAULT_NO: '2009' }, 'sessionStorage');

                ///Root Scope Constants
                $rootScope.constants = {
                    UBF_CRL_DEFAULT_YES: '2008',
                    UBF_CRL_DEFAULT_NO: '2009',
                };

                $rootScope.productVariables = {};
                $rootScope.productVariables.token = '123';
                var context = $rootScope.registry.localStore.global.context;
                $rootScope.productVariables.ApplicationID = context.ApplicationID;
                $rootScope.productVariables.ChannelAlias = context.ChannelAlias;
                //$rootScope.productVariables.ChannelAliases = contextService.context.ChannelAliases ;
                $rootScope.productVariables.ChannelID = context.ChannelID;
                $rootScope.productVariables.CountryID = context.CountryID;
                $rootScope.productVariables.EnvironmentType = context.EnvironmentType;
                $rootScope.productVariables.serviceHost        = 'services.lexus.monster.com';
                $rootScope.productVariables.rootUrl         = 'https://' + $rootScope.productVariables.serviceHost;
                $rootScope.productVariables.standardMask    = {
                    usPhone: "(999) 999-9999",
                    ssn: "999-99-9999",
                    usDate: '99/99/9999'
                };

                //caching section
                var caching = $rootScope.productVariables.caching = {};
                caching.cacheTypesEnum = {
                    sharedCache: 'shared',
                    httpSharedCache: 'httpShared',
                    privateCache: 'private',
                    httpPrivateCache: 'httpPrivate'                    
                };
                caching.cacheTypesDef = [
                    {
                        //shared with manual approach; e.g. messages, channel configs
                        cacheType: caching.cacheTypesEnum.sharedCache,
                        enabled: 'true',
                        initOptions: {
                            maxAge: 120 * 60 * 1000, // Items added to this cache expire after 2 hours
                            cacheFlushInterval: 120 * 60 * 1000, // This cache will clear itself every hour
                            deleteOnExpire: 'aggressive', // Items will be deleted from this cache when they expire
                            storageMode: 'localStorage' // This cache will use `localStorage`.
                        }
                    },
                    {
                        //shared with automatic approach (http cache); cached by url; e.g. lookups
                        cacheType: caching.cacheTypesEnum.httpSharedCache,
                        enabled: 'true',
                        initOptions: {
                            capacity: 40, //Maximum number of items a cache can hold. Adding more items than the capacity will cause the cache to operate like an LRU cache, removing the least recently used items to stay under capacity
                            maxAge: 60 * 60 * 1000, // Items added to this cache expire after 1 hour
                            cacheFlushInterval: 60 * 60 * 1000, // This cache will clear itself every hour
                            deleteOnExpire: 'aggressive', // Items will be deleted from this cache when they expire
                            storageMode: 'localStorage' // This cache will use `localStorage`.
                        }
                    },
                    {
                        //private with manual approach; specific to given session or user; e.g. login info
                        cacheType: caching.cacheTypesEnum.privateCache,
                        enabled: 'true',
                        initOptions: {
                            storageMode: 'sessionStorage' // This cache will use `localStorage`.
                        }
                    },
                    {
                        //private with automatic approach (http cache); e.g. cover letters, documents
                        cacheType: caching.cacheTypesEnum.httpPrivateCache,
                        enabled: 'false',
                        initOptions: {
                            capacity: 5, //Maximum number of items a cache can hold. Adding more items than the capacity will cause the cache to operate like an LRU cache, removing the least recently used items to stay under capacity
                            maxAge: 10 * 60 * 1000, // Items added to this cache expire after 10 mins
                            cacheFlushInterval: 30 * 60 * 1000, // This cache will clear itself every hour
                            deleteOnExpire: 'aggressive', // Items will be deleted from this cache when they expire
                            storageMode: 'sessionStorage' // This cache will use `localStorage`.
                        }
                    }
                    ];                

////    ?auth=EAAQSNV.iBCEoimL1L5EJBEJuk5ouBJntFQY.vic6I5DhNRmzkyBh96az1WQ4E1YBkbRmqdOr8gfi9xjwdx1eg3qQA-- 
                //function getParameterByName(name) {
                //    name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
                //    var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
                //        results = regex.exec(location.search);
                //    return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
                //}
                //var impersonationAuth = '{"auth":"' + getParameterByName('auth') + '"}';
                //if (impersonationAuth) {
                //    console.log('Sending:' + impersonationAuth);
                //    impersonate.post(impersonationAuth).$promise.then(function (data) {
                //        //console.log('Receving:' + data);
                //    });
                //}

            },
            add: function () {

            }
        }
    }
})();
(function () {
    'use strict';


    // registry (cheat sheet)
    //registry.set('global','mikeBoston', 1, 'sessionStorage');
    //registry.remove('global', 'mikeBoston', 'sessionStorage');
    //registry.remove('global', '', 'sessionStorage');

    //registry.addDelayedSave('budgetCalc', {val1: 1, val2: 2, val3:3 });
    //registry.removeDelayedSave('budgetCalc');
    //console.log($rootScope.registry.sessionStore);




    angular.module('globalApp').service('registry', ['$rootScope', '$window', serviceFunction]);
    function serviceFunction($rootScope, $window) {

        return {
            init: function () {

                //check for storage support
                if (typeof (Storage) !== "undefined") {

                    //init localStore Registry
                    if (!localStorage.registry) {
                        var registry = {
                            delayedSave: {}
                        };
                        localStorage.setItem('registry', JSON.stringify(registry));
                    }

                    //init SessionStore Registry
                    if (!sessionStorage.registry) {
                        var registry = {
                            delayedSave: {}
                        };
                        sessionStorage.setItem('registry', JSON.stringify(registry));
                    }

                    // set up and load the Live registry
                    $rootScope.registry = { localStore: {}, sessionStore: {} };
                    $rootScope.registry.localStore = JSON.parse(localStorage.registry);
                    $rootScope.registry.sessionStore = JSON.parse(sessionStorage.registry);

                } else {
                    // Sorry! No Web Storage support..
                }
            },

            // standard set and remove for simple variables
            set: function (nameSpace, name, value, type) {
                switch (type) {
                    case 'localStorage':
                        var registry = JSON.parse(localStorage.registry);           //get current local store of registry
                        if (typeof registry[nameSpace] === 'undefined') {
                            registry[nameSpace] = {};
                        }
                        registry[nameSpace][name] = value;                                     // add new name value pair to it
                        localStorage.setItem('registry', JSON.stringify(registry)); // set the updated object back to local store
                        this.init();                                                // re initilize live version of the registry
                        break;

                    case 'sessionStorage':
                        var registry = JSON.parse(sessionStorage.registry);             //get current session store of registry
                        if (typeof registry[nameSpace] === 'undefined') {
                            registry[nameSpace] = {};
                        }
                        registry[nameSpace][name] = value;                                         // add new name value pair to it
                        sessionStorage.setItem('registry', JSON.stringify(registry));   // set the updated object back to local store
                        this.init();                                                    // re initilize live version of the registry
                        break;

                    // todo : support cookies

                }
            },
            getDelayedSave: function (name, type) {
                return JSON.parse($window[type].registry).delayedSave[name];
            },
            getAll: function (type) {
                return JSON.parse($window[type].registry);
            },
            get: function (nameSpace, name, type) {
                var registry
                switch(type)
                {
                    case 'localStorage':
                        registry = JSON.parse(localStorage.registry);
                        break;
                    case 'sessionStorage':
                        registry = JSON.parse(sessionStorage.registry);
                        break;
                }
                var section = registry[nameSpace];
                if (typeof section !== "undefined")
                {
                    return section[name];
                }
            },
            remove: function (nameSpace, name, type) {
                switch (type) {
                    case 'localStorage':
                        var registry = JSON.parse(localStorage.registry);           //get current local store of registry
                        if (nameSpace && !name) {
                            delete registry[nameSpace];                                 // remove from object
                        }
                        else {
                            delete registry[nameSpace][name];                           // remove from object
                        }
                        localStorage.removeItem('registry')                         // remove the registry from local store
                        localStorage.setItem('registry', JSON.stringify(registry)); // set the updated object back to local store
                        this.init();                                                // re initilize live version of the registry
                        break;

                    case 'sessionStorage':
                        var registry = JSON.parse(sessionStorage.registry);             //get current session store of registry
                        if (nameSpace && !name) {
                            delete registry[nameSpace];                                 // remove from object
                        }
                        else{
                            delete registry[nameSpace][name];                           // remove from object
                        }
                        sessionStorage.removeItem('registry')                           // remove the registry from local store
                        sessionStorage.setItem('registry', JSON.stringify(registry));   // set the updated object back to local store
                        this.init();                                                    // re initilize live version of the registry
                        break;

                    // todo : support cookies

                }
            },
            purge: function(){
                localStorage.removeItem('registry');
                sessionStorage.removeItem('registry');
                this.init();
            },

            //type is defaulted to sessionStorage, if need localStorage provide it as a type
            addDelayedSave: function (name, value, type) {
                var storage = (type === 'localStorage') ? localStorage : sessionStorage;
                var registry = JSON.parse(storage.registry);
                if (!registry.delayedSave) registry.delayedSave = {};
                registry.delayedSave[name] = value;
                storage.removeItem('registry');
                storage.setItem('registry', JSON.stringify(registry));
                this.init();
            },

            removeDelayedSave: function (name, type) {
                var storage = (type === 'localStorage') ? localStorage : sessionStorage;
                var registry = JSON.parse(storage.registry);
                delete registry.delayedSave[name];
                storage.removeItem('registry');
                storage.setItem('registry', JSON.stringify(registry));
                this.init();
            },

            // custom type, (within sessionStore) used to hold delayed save data, this is used when the user is not yet logged in.
            //addDelayedSave: function (name, value) {
            //    var registry = JSON.parse(sessionStorage.registry);             
            //    registry.delayedSave[name] = value;                             
            //    sessionStorage.removeItem('registry');
            //    sessionStorage.setItem('registry', JSON.stringify(registry));   
            //    this.init();                                                    
            //},
            //removeDelayedSave: function (name) {
            //    var registry = JSON.parse(sessionStorage.registry);             
            //    delete registry.delayedSave[name];                             
            //    sessionStorage.removeItem('registry');
            //    sessionStorage.setItem('registry', JSON.stringify(registry));   
            //    this.init();                                                    
            //},

        }
    }

})();
(function (angular) {
    "use strict";
    angular.module("globalApp").service('templateUrlService', ['$rootScope', function ($rootScope) {
        var _overrides = [];

        return {
            addOverride: function (alias, overrideUrl) {
                if (typeof alias !== "string") {
                    throw new Error("alias is not a string");
                }
                if (typeof overrideUrl !== "string") {
                    throw new Error("overrideUrl is not a string");
                }
                alias = alias.toLowerCase();
                _overrides[alias] = overrideUrl;
            },
            get: function (alias) {
                if (typeof alias !== "string") {
                    throw new Error("alias is not a string");
                }
                alias = alias.toLowerCase();
                var result = _overrides[alias];
                if (typeof result === "undefined")
                {
                    return $rootScope.registry.localStore.global.context.templateUrl + alias;
                }
                return result;
            }
        };
    }]);
})(angular);
(function () {

    angular.module('globalApp').service('timeoutManager', ['$rootScope', '$timeout', '$interval', 'authentication', '$uibModal', timeoutManager]);

    function timeoutManager($rootScope, $timeout, $interval, authentication, $uibModal) {
        var service = this;

        //                                                                               _______________
        // _____________________________________________________________________________/   Public API  \_____

        service.start = start;
        service.stop = stop;
        service.isServiceRunning = isServiceRunning;


        //                                                                               _______________________
        // _____________________________________________________________________________/   Internal variables  \_____

        var _const = {
            MINUTE_IN_MILISECONDS: 60 * 1000
        };

        //settings which will not get overriden by configuration via _options
        var _base = {
            checkActivityTimeInterval: _const.MINUTE_IN_MILISECONDS
        };

        //settings that are taken as defaults if _options configuration: a) does not define them or b) defines incorrect values
        var _defaults = {
            showWarning: true,
            timeToWarning: 10 * _const.MINUTE_IN_MILISECONDS,
            timeToLogOut: 20 * _const.MINUTE_IN_MILISECONDS
        };

        //settings that are taken from parameter given by caller when starting the service by timeoutManager.start(options)
        var _options = {};

        //final settings that are used by service
        //they are defined by merging of _base -> _options -> _defaults
        var _settings = {};


        var _status = {
            started: false,
            userIsActive: false,
            warningStarted: false
        };
        

        //                                                                               _______________________
        // _____________________________________________________________________________/   $rootScope binding  \_____

        $rootScope.timeoutManager = {};
        $rootScope.timeoutManager.timeRemainingBeforeLogout = "";


        //                                                                               _________________________
        // _____________________________________________________________________________/   Public API functions  \_____


        function start(options) {
            _processOptions(options);
            if (_settings.showWarning) {
                _finalizeSettings();
                _initStatus();
                _watchActivity();
                _checkActivity();
            }
        }


        function stop() {
            _status.started = false;
            _stopWarning();
        }


        function isServiceRunning() {
            return _status.started;
        }


        //                                                                               ______________________
        // _____________________________________________________________________________/   Private functions  \_____


        function _processOptions(options) {
            if (typeof (options) !== 'undefined' && typeof (options) === 'object') {
                _options = _checkOptions(options);
            }
            angular.merge(_settings, _defaults, _options, _base);
        }

        function _checkOptions(options) {
            var optionsChecked = options;
            optionsChecked = _checkShowWarning(optionsChecked);
            optionsChecked = _checkTimeToWarning(optionsChecked);
            optionsChecked = _checkTimeToLogOut(optionsChecked);
            return optionsChecked;
        }

        function _checkShowWarning(options) {
            var showWarning;
            switch (typeof (options.showWarning)) {
                case "boolean":
                    showWarning = options.showWarning;
                    break;
                case "string":
                    showWarning = options.showWarning.trim().toLowerCase() == 'true' ? true : false;
                    break;

            }
            if (typeof (showWarning) !== 'undefined') {
                options.showWarning = showWarning;
            }
            return options;
        }

        function _toNumber(value) {
            var numberValue = 0;
            switch (typeof (value)) {
                case "string":
                    numberValue = Number(value.trim());
                    break;
                case "number":
                    numberValue = value;
                    break;
            }
            return numberValue;
        }

        function _checkTimeToWarning(options) {
            var timeToWarning = _toNumber(options.timeToWarning);
            if (timeToWarning > 0) {
                options.timeToWarning = timeToWarning;
            } else {
                delete options.timeToWarning;
            }
            return options;
        }

        function _checkTimeToLogOut(options) {
            var timeToLogOut = _toNumber(options.timeToLogOut);
            if (timeToLogOut > 0) {
                options.timeToLogOut = timeToLogOut;
            } else {
                delete options.timeToLogOut;
            }
            return options;
        }

        function _finalizeSettings() {
            _settings = _compareWarningLogoutTimes(_settings);
            _countTimesInMinutes();
        }

        function _compareWarningLogoutTimes(options) {
            if (options.timeToLogOut <= options.timeToWarning) {
                options.timeToLogOut = options.timeToWarning + _const.MINUTE_IN_MILISECONDS;
            }
            return options;
        }

        function _countTimesInMinutes() {
            _settings.minutesOfInactivityBeforeWarning = _milisecondsToMinutes(_settings.timeToWarning);
            _settings.minutesOfInactivityBeforeLogout = _milisecondsToMinutes(_settings.timeToLogOut);
        }

        function _milisecondsToMinutes(timeInMiliseconds) {
            return Math.round(timeInMiliseconds / _const.MINUTE_IN_MILISECONDS);
        }

        function _initStatus() {
            _status.started = true;
            _resetRemainingTime();
        }

        function _checkActivity(checkActivityTimeInterval) {
            if (typeof (checkActivityTimeInterval) === 'undefined') {
                checkActivityTimeInterval = 0;
            }
            $timeout(function () {
                _checkActivityUnit();
                if (service.isServiceRunning()) {
                    _checkActivity(_settings.checkActivityTimeInterval);
                }
            }, checkActivityTimeInterval);
        }

        function _checkActivityUnit() {
            if (_status.userIsActive === false) {
                _checkForWarningTime();
                _checkForLogoutTime();
                _decreaseRemainingTime();
            } else {
                _prolong();
                _setUserIsInactive();
            }
        }

        function _checkForWarningTime() {
            if (_status.numOfTimeUnitsBeforeWarning <= 0 && !_status.warningStarted) {
                _startWarning();
            }
        }

        function _checkForLogoutTime() {
            if (_status.numOfTimeUnitsBeforeLogout <= 0) {
                _startLogoutProcess();
            }
        }

        function _startLogoutProcess() {
            service.stop();
            _manageLoggedOutModal();
            _callLogout();
        }

        function _callLogout() {
            //$rootScope.isAuthenticated = false;
            authentication.logout();
        }


        function _decreaseRemainingTime() {
            _decreaseNumOfTimeUnitsBeforeWarning();
            _decreaseNumOfTimeUnitsBeforeLogout();
        }

        function _decreaseNumOfTimeUnitsBeforeWarning() {
            if (_status.numOfTimeUnitsBeforeWarning > 0) {
                _status.numOfTimeUnitsBeforeWarning--;
            }
        }

        function _decreaseNumOfTimeUnitsBeforeLogout() {
            if (_status.numOfTimeUnitsBeforeLogout > 0) {
                _status.numOfTimeUnitsBeforeLogout--;
            }
        }

        function _resetRemainingTime() {
            _status.numOfTimeUnitsBeforeWarning = _settings.minutesOfInactivityBeforeWarning;
            _status.numOfTimeUnitsBeforeLogout = _settings.minutesOfInactivityBeforeLogout;
        }

        function _prolong() {
            _resetRemainingTime();
            _stopWarning();
        }

        function _setUserIsActive() {
            _status.userIsActive = true;
        }

        function _setUserIsInactive() {
            _status.userIsActive = false;
        }

        function _getTimeRemainingBeforeLogout() {
            var time = { totalSeconds: _status.timeRemainingBeforeLogout };
            time.minutes = Math.floor(_status.timeRemainingBeforeLogout / 60);
            var seconds = _status.timeRemainingBeforeLogout % 60;
            time.seconds = seconds > 9 ? seconds : "0" + seconds;
            return time;
        }

        function _countTimeRemainingBeforeLogout() {
            return _status.numOfTimeUnitsBeforeLogout * 60;
        }

        function _setTimeRemainingBeforeLogout() {
            _status.timeRemainingBeforeLogout = _countTimeRemainingBeforeLogout();
            $rootScope.timeoutManager.timeRemainingBeforeLogout = _getFormattedTimeRemainingBeforeLogout();
        }

        function _decreaseTimeRemainingBeforeLogout() {
            _status.timeRemainingBeforeLogout--;
        }

        function _getFormattedTimeRemainingBeforeLogout() {
            var remainingTime = _getTimeRemainingBeforeLogout();
            var remainingTimeText = remainingTime.minutes + ":" + remainingTime.seconds;
            return remainingTimeText;
        }

        function _startDecreasingTimeRemainingBeforeLogout() {
            service.TimeRemainingBeforeLogoutCountdown = $interval(_updateTimeRemainingBeforeLogout, 1000);
        }

        function _updateTimeRemainingBeforeLogout() {
            _decreaseTimeRemainingBeforeLogout();
            $rootScope.timeoutManager.timeRemainingBeforeLogout = _getFormattedTimeRemainingBeforeLogout();
        }

        function _manageTimeRemainingBeforeLogout() {
            _setTimeRemainingBeforeLogout();
            _startDecreasingTimeRemainingBeforeLogout();
        }

        function _manageWarningModal() {
            service.WarningModalInstance = $uibModal.open({
                animation: true,
                templateUrl: 'modalTimeoutWarning.html',
                controller: 'ModalInstanceCtrl',
                resolve: {
                }
            });
            service.WarningModalInstance.result.then(function () {
                _prolong();
            }, function () {
                _prolong();
            });
        }

        function _manageLoggedOutModal() {
            service.LoggedOutModalInstance = $uibModal.open({
                animation: true,
                templateUrl: 'modalTimeoutLoggedOut.html',
                controller: 'ModalInstanceCtrl',
                resolve: {
                }
            });
        }

        function _startWarning() {
            _status.warningStarted = true;
            _manageTimeRemainingBeforeLogout();
            _manageWarningModal();
        }

        function _stopWarning() {
            _status.warningStarted = false;
            if(service.WarningModalInstance){
                service.WarningModalInstance.close();
            }
            $interval.cancel(service.TimeRemainingBeforeLogoutCountdown);
        }

        function _watchActivity() {
            _watchClick();
            _watchKeydown();
            _watchScroll();
        }

        function _watchClick() {
            $(document).on("click", function () {
                _setUserIsActive();
            });
        }

        function _watchKeydown() {
            $(document).on("keydown", function () {
                _setUserIsActive();
            });
        }

        function _watchScroll() {
            $(window).scroll(function () {
                _setUserIsActive();
            });
        }

    }

})();
(function (angular) {
    "use strict";
    angular.module('globalApp').service('titleService', ['$rootScope',  function ($rootScope) {

        return {
            setTitle: function (keywords, title) {
                var pageTitle = $rootScope.meta.messages[title].lookUpMsg.value;
                var pageKeys = '';//$rootScope.meta.messages[keywords].lookUpMsg.value;
                var separator1 = (pageKeys === '') ? '' : ' - ';
                var separator2 = (pageTitle === '') ? '' : ' - ';
                $rootScope.pageTitle = pageKeys + separator1 + pageTitle + separator2 + $rootScope.meta.messages[194808].lookUpMsg.value;
            }
        };
    }]);
})(angular);

(function (angular) {
    "use strict";
    angular.module('globalApp').service('trackService', ['$rootScope', '$window', '$location', '$q', 'registry', function ($rootScope, $window, $location, $q, registry) {
        var _sinks = [];
        var _activeSinks = [];
        var _ready = false;
        var _queue = [];
       
        function track(event) {
            if (typeof event !== "object") {
                throw new Error('event should be of \'object\' type');
            }
            if (typeof event.name !== "string") {
                throw new Error('event.name should be string');
            }
            if (_ready) {
                angular.forEach(_activeSinks, function (sink) {
                    try {
                        sink.track(event);
                    }
                    catch (e) {
                        console.error(e);
                    }
                });
            }
            else {
                _queue.push(event);
            }
        }

        return {
            addSink: function(sink) {
                _sinks.push(sink);
            },
            configure: function(configs) {
                for(var i = 0; i < configs.length; i++)
                {
                    var config = configs[i];
                    var promises = [];
                    angular.forEach(_sinks, function (sink) {
                        if (sink.name === config.name)
                        {
                            var deferred = $q.defer();
                            promises.push(deferred.promise);
                            sink.configure(config).then(function () {
                                _activeSinks.push(sink);
                                deferred.resolve();
                            });
                        }
                    });
                    $q.all(promises).then(function () {
                        _ready = true;
                        if (_queue.length > 0) {
                            angular.forEach(_queue, function (item) {
                                track(item);
                            });
                            _queue = [];
                        }
                    });
                }
            },
            init: function () {
                $rootScope.track = track;
            }
        };
    }]);
})(angular);
(function () {
    "use strict";
    // various helper functions; as a rule of thumb if function you're about to add needs 
    // any dependency (existing service, factory, etc.) it doesn't belong here
    angular.module("globalApp").service("utilityService", [utilityService]);

    function utilityService() {
        this.tokenize = tokenize;
        this.forEach = forEach;
        this.replaceCoreEmailLink = replaceCoreEmailLink;
        this.getShortenedText = getShortenedText;
    }

    function forEach(node, callback) {
        var stack = [{ node: node, path: [] }];
        var walked = [];
        while (stack.length > 0) {
            var item = stack.pop();
            var node = item.node;
            var key;
            for (key in item.node) {
                if (typeof node[key] === 'object' && !key.startsWith('$')) {
                    var alreadyFound = false;
                    for (var i = 0; i < walked.length; i++) {
                        if (walked[i] === node[key]) {
                            alreadyFound = true;
                            break;
                        }
                    }
                    if (!alreadyFound) {
                        var path = item.path.slice();
                        path.push(node);
                        stack.push({ node: node[key], path: path });
                        if (callback) {
                            callback(node[key], path.slice());
                        }
                    }
                }
            }
        }
    }

    function tokenize(phrase) {
        var maxLength = 100;

        if (!phrase)
        {
            return phrase;
        }

        var returnString = phrase.toLowerCase();
        //Convert Characters
        returnString = returnString.replace(//g, 'o');
        returnString = returnString.replace(//g, 'c');
        returnString = returnString.replace(//g, 's');
        returnString = returnString.replace(//g, 'i');
        returnString = returnString.replace(//g, 'g');
        returnString = returnString.replace(//g, 'u');

        // if there are other invalid chars, convert them into blank spaces
        returnString = returnString.replace(/[^a-z0-9\s-]/g, "");
        // convert multiple spaces and hyphens into one space       
        returnString = returnString.replace(/[\s-]+/g, " ");
        // trims current string
        returnString = returnString.replace(/^\s+|\s+$/g, "");
        // cuts string (if too long)
        if (returnString.length > maxLength)
            returnString = returnString.substring(0, maxLength);
        // add hyphens
        returnString = returnString.replace(/\s/g, "-");

        return returnString;
    }

    function replaceCoreEmailLink(frame) {
        var frameDoc = frame.contentWindow ? frame.contentWindow.document : frame.contentDocument;
        var emailLink = frameDoc.querySelector('#ContactEmailLink');
        if (emailLink) {
            emailLink.href = '#';
            $(emailLink).on('click', function () {
                top.window.location.hash = top.window.location.hash + '/apply-by-email';
            });
        }
    }

    function getShortenedText(text, maxlength) {
        if (text && maxlength) {
            return (text.length > maxlength) ? text.substr(0, maxlength) + "..." : text;
        } else {
            return text;
        }
    }

})();
(function () {
    'use strict';

    angular.module('globalApp').factory('accountResetFactory',['$resource', '$rootScope', factoryFunction]);

    function factoryFunction($resource, $rootScope) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/core/api/security/forgot-password/';
        var factory = $resource(resourceUrl + '/:username', { userName: '@username' }, {
            getSecretQA: { url: resourceUrl, method: 'GET', isArray: true },

            resetPasswordOnline: {
                url: resourceUrl + 'reset/:userName',
                params: { userName: '@userName'},
                method: 'POST',
                data: '@secretQAModel' , isArray: false,
            },
            sendResetEmail: {
                url: resourceUrl + 'reset/:email',
                params: { email: '@email' },
                method: 'PUT',
                isArray: false
            },
            getSecretQuestion: {
                url: resourceUrl + ':userName',
                params: { userName: '@userName' },
                method: 'GET',
                isArray: false
            },
            resetpassword: {
                url: resourceUrl + 'resetpassword',
                params: { token: '@token', password: '@password' },
                method: 'PUT'
            }

        });
        return factory;
    };


})();
(function () {
    'use strict';

    var LOGIN = {
        Lexus: 0,
        Sso: 1
    };

    function authenticationStorage($window, $rootScope) {
        var factory = {};

        function getKey(key) {
            return $rootScope.productVariables.ChannelID.toString() + ':' + key;
        }

        factory.getAuthenticationType = function () {
            return $window.sessionStorage.getItem(getKey('login_type_key'));
        };

        factory.setAuthenticationType = function (type) {
            $window.sessionStorage.setItem(getKey('login_type_key'), type);
        };

        factory.getMillisecondsToProlong = function () {
            var prolongDate = this.getProlongDate();
            if (prolongDate) {
                return prolongDate.getTime() - (new Date()).getTime();
            }
            return null;
        };

        factory.setProlongDate = function (date) {
            if (!(date instanceof Date))
            {
                throw Error('date should be of Date type.');
            }
            $window.sessionStorage.setItem(getKey('prolong_date_key'), date.getTime());
        };

        factory.getProlongDate = function () {
            var milliseconds = $window.sessionStorage.getItem(getKey('prolong_date_key'));
            if (!milliseconds)
            {
                return null;
            }
            var result = new Date();
            result.setTime(parseInt(milliseconds));
            return result;
        };

        factory.getImpersonation = function () {
            var result = $window.sessionStorage.getItem(getKey('webadmin_impersonation_key'));
            if (result)
            {
                return JSON.parse(result);
            }
            return {};
        };

        factory.setImpersonation = function (impersonation) {
            var value = null;
            if (impersonation)
            {
                value = JSON.stringify(impersonation);
            }
            $window.sessionStorage.setItem(getKey('webadmin_impersonation_key'), value);
        };

        factory.getToken = function () {
            var type = this.getAuthenticationType();
            if (type) {
                if (type == LOGIN.Lexus) {
                    return $window.sessionStorage.getItem(getKey('login_token_key'));
                }
                if (type == LOGIN.Sso) {
                    return $window.mgr.access_token;
                }
            }
        };

        factory.clearRedirectUrl = function () {
            $window.sessionStorage.removeItem(getKey('redirect_key'));
        };

        factory.setRedirectUrl = function (url) {
            $window.sessionStorage.setItem(getKey('redirect_key'), url);
        };

        factory.getRedirectUrl = function () {
            return $window.sessionStorage.getItem(getKey('redirect_key'));
        };

        factory.setLexusToken = function (token) {
            $window.sessionStorage.setItem(getKey('login_token_key'), token);
        };

        factory.setUser = function (user) {
            $window.sessionStorage.setItem(getKey('user_key'), JSON.stringify(user));
        };

        factory.getUser = function () {
            var user = $window.sessionStorage.getItem(getKey('user_key'));
            if (user)
            {
                return JSON.parse(user);
            }
            return null;
        };

        factory.setAuthenticateUsingSaml = function (authWithSaml) {
            $window.sessionStorage.setItem(getKey('authenticate_using_saml'), authWithSaml);
        }

        factory.getAuthenticateUsingSaml = function () {
            return $window.sessionStorage.getItem(getKey('authenticate_using_saml'));
        }

        factory.setIdpAuthCookieName = function (cookieName) {
            $window.sessionStorage.setItem(getKey('idp_auth_cookie_name'), cookieName);
        }

        factory.getIdpAuthCookieName = function () {
            return $window.sessionStorage.getItem(getKey('idp_auth_cookie_name'));
        }

        factory.clear = function () {
            $window.mgr.removeToken();
            $window.sessionStorage.removeItem(getKey('login_token_key'));
            $window.sessionStorage.removeItem(getKey('webadmin_impersonation_key'));
            $window.sessionStorage.removeItem(getKey('login_type_key'));
            $window.sessionStorage.removeItem(getKey('prolong_date_key'));
            $window.sessionStorage.removeItem(getKey('user_key'));
            $window.sessionStorage.removeItem(getKey('redirect_key'));
            $window.sessionStorage.removeItem(getKey('authenticate_using_saml'));
            $window.sessionStorage.removeItem(getKey('idp_auth_cookie_name'));
        };

        return factory;
    };
    authenticationStorage.$inject = ['$window', '$rootScope'];
    angular.module('globalApp').factory('authenticationStorage', authenticationStorage);

    function authenticationFactory($window, $resource, $rootScope, $timeout, $location, authenticationStorage) {
        var factory = {};

        var renewalPromise = null;

        factory.scheduleRenewal = function () {
            if (!renewalPromise && authenticationStorage.getMillisecondsToProlong())
            {
                renewalPromise = $timeout(function () {
                    var resourceUrl = $rootScope.productVariables.rootUrl + '/core/api/security/prolong-token';
                    var prolong = $resource(resourceUrl, {}, {
                        post: { method: 'POST', isArray: false, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false }
                    });
                    return prolong.post()
                    .$promise
                    .then(function (data) {
                        factory.loginCallback(data);
                        return data.success;
                    });
                }, authenticationStorage.getMillisecondsToProlong())
            }
        };


        factory.setup = function (fOnLoggedIn, fOnLoggedOut, allowAnonymous) {
            if (fOnLoggedIn)
            {
                $rootScope.$on("login_success", fOnLoggedIn);
            }
            if (fOnLoggedOut)
            {
                $rootScope.$on("logout_success", fOnLoggedOut);
            }
            
            if (!this.isAuthenticated()) {
                authenticationStorage.setRedirectUrl($location.absUrl());
                if (!$rootScope.login) {
                    $rootScope.login = {};
                }
                if (!allowAnonymous)
                {
                    //$rootScope.login.boxOpen = true;
                }
                if (fOnLoggedOut)
                {
                    fOnLoggedOut();
                }
            } else
            {
                if (fOnLoggedIn)
                {
                    fOnLoggedIn();
                }
            }
        };

        factory.loginCallback = function (authentication, user) {
            if (authentication && authentication.success)
            {
                authenticationStorage.setAuthenticationType(LOGIN.Lexus);
                authenticationStorage.setLexusToken(authentication.token);
                authenticationStorage.setImpersonation(authentication.webAdminImpersonation);
                $rootScope.isAuthenticated = factory.isAuthenticated();
                var now = new Date();
                now.setSeconds(now.getSeconds() + authentication.expiresInSeconds / 2);
                authenticationStorage.setProlongDate(now);
                if (renewalPromise)
                {
                    $timeout.cancel(renewalPromise);
                    renewalPromise = null;
                }
                factory.scheduleRenewal();
                if (user)
                {
                    authenticationStorage.setUser(user);
                }
            }
        };

        factory.login = function (email, password) {
            var resourceUrl = $rootScope.productVariables.rootUrl + '/core/api/security/local-login';
            var localLogin = $resource(resourceUrl, {}, {
                post: { method: 'POST', isArray: false, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false }
            });
            return localLogin.post({ email: email, password: password })
            .$promise
            .then(function (response) {
                var success = response.authentication && response.authentication.success;
                if (success) {
                    factory.loginCallback(response.authentication, response);
                    $rootScope.$broadcast('login_success');
                    var url = authenticationStorage.getRedirectUrl();
                    if (!url)
                    {
                        url = '/dashboard#/';
                    }
                    authenticationStorage.clearRedirectUrl();
                    return { success: success, url: url };
                }
                return { success: false };
            });
        };

        factory.impersonate = function (webAdminAuthenticationToken) {
            var resourceUrl = $rootScope.productVariables.rootUrl + '/core/api/security/impersonate';
            var impersonateCall = $resource(resourceUrl, {}, {
                post : { method: 'POST', isArray: false, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false }
            });
            return impersonateCall.post({ auth: webAdminAuthenticationToken})
            .$promise
            .then(function (response) {
                if (response.authentication && response.authentication.success) {
                    factory.loginCallback(response.authentication, response);
                    $window.location = '/';
                }
            });
        };

        factory.isAuthenticated = function () {
            var token = authenticationStorage.getToken();
            var result = (typeof token !== "undefined") && token !== null && token !== "";
            return result;
        };

        factory.impersonation = function () {
            if (!factory.isAuthenticated())
            {
                return {};
            }
            return authenticationStorage.getImpersonation();
        };

        factory.logout = function () {
            var type = authenticationStorage.getAuthenticationType();
            if (type == LOGIN.Sso) {
                $window.mgr.redirectForLogout();
                return;
            }
            if (type == LOGIN.Lexus)
            {
                authenticationStorage.clear();
                $rootScope.isAuthenticated = false;
                $rootScope.$broadcast('logout_success');
            }
        };

        factory.isAuthenticatingUsingSaml = function () {
            var config = authenticationStorage.getAuthenticateUsingSaml();
            var result = (typeof config !== "undefined") && config !== null && config.toLowerCase() == "true";
            return result;
        }

        $rootScope.isAuthenticated = factory.isAuthenticated();
        $rootScope.impersonation = factory.impersonation();

        return factory;
    };

    authenticationFactory.$inject = ['$window', '$resource', '$rootScope', '$timeout', '$location', 'authenticationStorage'];
    angular.module('globalApp').factory('authentication', authenticationFactory);
})();
(function () {
    'use strict';

    angular.module('globalApp').factory('getTokenLocalLogin', ['$resource', '$rootScope', 'errorDispatch', factoryFunction]);

    function factoryFunction($resource, $rootScope, errorDispatch) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/core/api/security/local-login';
        var factory = $resource(resourceUrl, null,
            {
                post: { method: 'POST', isArray: false, interceptor: { responseError: errorDispatch.alertError }, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false }
            }
        );
        return factory;
    };

})();



(function () {
    'use strict';

    angular.module('globalApp').factory("impersonate", ['$resource', '$rootScope', factoryFunction]);
    
    function factoryFunction($resource, $rootScope) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/core/api/security/impersonate';
        return $resource(resourceUrl, {}, {
            post: { method: 'POST', isArray: false, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false },
        });
    };
})();


(function () {
    'use strict';

    angular.module('globalApp').factory('userFactory',['$resource', '$rootScope', factoryFunction]);

    function factoryFunction($resource, $rootScope) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/seeker/api/user/';
        var factory = $resource(resourceUrl, null,
            {
                'getByToken': {
                    url: resourceUrl + '/:token',
                    params: { agentID: '@token' },
                    method: 'GET'
                },
            }
        );
        return factory;
    };


})();
(function (angular) {
    'use strict';

    angular.module('globalApp').factory('autoCompleteFactory', ['$resource', '$rootScope', factoryFunction]);
    
    function factoryFunction($resource, $rootScope) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/core/api/queries/';

        return $resource(resourceUrl, null, {
            locations: {
                method: 'GET',
                url: resourceUrl + 'locations?countryId=:countryId&query=:query',
                params: {
                    countryId: '@countryId',
                    query: '@query'
                }
            },
            skills: {
                method: 'GET',
                url: resourceUrl + 'entities/skills?query=:query',
                params: {
                    query: '@query'
                }
            },
            certifications: {
                method: 'GET',
                url: resourceUrl + 'certifications?query=:query',
                params: {
                    query: '@query'
                }
            },
            certificationinstitutions: {
                method: 'GET',
                url: resourceUrl + 'certificationinstitutions?query=:query',
                params: {
                    query: '@query'
                }
            }
        });
    };
})(angular);

(function () {
    'use strict';

    angular.module('globalApp').factory("builderFieldId", ['$resource', '$rootScope', factoryFunction]);

    function factoryFunction($resource, $rootScope) {
        var resourceUrl = $rootScope.productVariables.rootUrl + "/core/api/lookups/builderfields/:lookUp";
        return $resource(resourceUrl, {}, {
            get: { method: 'GET', isArray: false, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false },
        });
    };
})();




(function () {
    'use strict';

    angular.module('globalApp').factory("getFieldInfo", ['$resource', '$rootScope', factoryFunction]);

    function factoryFunction($resource, $rootScope) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/core/api/lookups/custom-lookups/list-by-name/:lookUp';
        return $resource(resourceUrl, {}, {
            get: { method: 'GET', isArray: true, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false },
        });
    };
})();





(function () {
    'use strict';
    angular.module('globalApp').factory("getLookupByName", ['$resource', '$rootScope', 'cacheService', factoryFunction]);
    function factoryFunction($resource, $rootScope, cacheService) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/core/api/lookups/:name';
        return $resource(resourceUrl, {}, {
            get: {
                method: 'GET', isArray: false, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false
            }
        });
    }

})();



(function () {
    'use strict';
    angular.module('globalApp').factory("getLookup", ['$resource', '$rootScope', 'cacheService', 'errorDispatch', factoryFunction])

    function factoryFunction($resource, $rootScope, cacheService, errorDispatch) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/core/api/lookups/by-name/:name';
        return $resource(resourceUrl, {}, {
            get: {
                method: 'GET', isArray: false, requestType: 'json', interceptor: { responseError: errorDispatch.alertError }, responseType: 'json', contentType: "json/application", cache: false
            }
        });
    }
})();


(function () {
    'use strict';

    angular.module('globalApp').factory("getLanguages", ['$resource', '$rootScope', 'cacheService', factoryFunction]);

    function factoryFunction($resource, $rootScope, cacheService) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/core/api/lookups/languages';
        //var cache = cacheService.provider($rootScope.productVariables.caching.cacheTypesEnum.httpSharedCache).cache;
        return $resource(resourceUrl, {}, {
            get: {
                method: 'GET', isArray: false, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false
            }
        });
    };

})();

(function () {
    'use strict';

    angular.module('globalApp').factory("getLanguageProficiencies", ['$resource', '$rootScope', 'cacheService', factoryFunction]);

    function factoryFunction($resource, $rootScope, cacheService) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/core/api/lookups/language-proficiencies';
        //var cache = cacheService.provider($rootScope.productVariables.caching.cacheTypesEnum.httpSharedCache).cache;
        return $resource(resourceUrl, {}, {
            get: {
                method: 'GET', isArray: false, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false
            }
        });
    };

})();

(function () {
    'use strict';

    angular.module('globalApp').factory("getStates", ['$resource', '$rootScope', 'cacheService', factoryFunction]);
    
    function factoryFunction($resource, $rootScope, cacheService) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/core/api/lookups/countries/:countryId/states';
        //var cache = cacheService.provider($rootScope.productVariables.caching.cacheTypesEnum.httpSharedCache).cache;
        return $resource(resourceUrl, {}, {
            get: {
                method: 'GET', isArray: false, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false }
        });
    };

})();

(function () {
    'use strict';

    angular.module('globalApp').factory("getStatesText", ['$resource', '$rootScope', 'cacheService', factoryFunction]);

    function factoryFunction($resource, $rootScope, cacheService) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/core/api/lookups/countries/:countryId/statestext';
        return $resource(resourceUrl, {}, {
            get: {
                method: 'GET', isArray: false, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false
            }
        });
    };

})();



(function () {
    'use strict';

    angular.module('globalApp').factory("getStatesAbbr", ['$resource', '$rootScope', 'cacheService', factoryFunction]);
    
    function factoryFunction($resource, $rootScope, cacheService) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/core/api/lookups/countries/:countryId/states_abbr';
        //var cache = cacheService.provider($rootScope.productVariables.caching.cacheTypesEnum.httpSharedCache).cache;
        return $resource(resourceUrl, {}, {
            get: {
                method: 'GET', isArray: false, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false }
        });
    };

})();




(function () {
    'use strict';

    angular.module('globalApp').factory("geoLocation", ['$resource', '$rootScope', factoryFunction]);
    
    function factoryFunction($resource, $rootScope) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/core/api/lookups/geolocations/:zipCode';
        return $resource(resourceUrl, {}, {
            get: {
                method: 'GET', isArray: false, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false }
        });
    };

})();




(function () {
    'use strict';

    angular.module('globalApp').factory("getOccupationIndustries", ['$resource', '$rootScope', 'cacheService', factoryFunction]);
    
    function factoryFunction($resource, $rootScope, cacheService) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/seeker/api/lookups/occupations/industries';
        //var cache = cacheService.provider($rootScope.productVariables.caching.cacheTypesEnum.httpSharedCache).cache;
        return $resource(resourceUrl, {}, {
            get: {
                method: 'GET', isArray: true, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false }
        });
    };

})();




(function () {
    'use strict';

    angular.module('globalApp').factory("getOccupationMilitaryBranches", ['$resource', '$rootScope', 'cacheService', factoryFunction]);
    
    function factoryFunction($resource, $rootScope, cacheService) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/core/api/lookups/custom-lookups/52221';
        //var cache = cacheService.provider($rootScope.productVariables.caching.cacheTypesEnum.httpSharedCache).cache;
        return $resource(resourceUrl, {}, {
            get: {
                method: 'GET', isArray: true, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false }
        });
    };

})();



(function () {
    'use strict';

    angular.module('globalApp').factory("getCustomLookupOnId", ['$resource', '$rootScope', 'cacheService', factoryFunction]);

    function factoryFunction($resource, $rootScope, cacheService) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/core/api/lookups/custom-lookups/:id';
        //var cache = cacheService.provider($rootScope.productVariables.caching.cacheTypesEnum.httpSharedCache).cache;
        return $resource(resourceUrl, {}, {
            get: {
                method: 'GET', isArray: true, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false
            }
        });
    };

})();

(function () {
    'use strict';

    angular.module('globalApp').factory("getCustomLookupOnIdParentId", ['$resource', '$rootScope', 'cacheService', factoryFunction]);

    function factoryFunction($resource, $rootScope, cacheService) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/core/api/lookups/custom-lookups/:id/:parentId';
        return $resource(resourceUrl, {}, {
            get: {
                method: 'GET', isArray: true, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false
            }
        });
    };

})();



(function () {
    'use strict';

    angular.module('globalApp').factory("compareOccupations", ['$resource', '$rootScope', factoryFunction]);
    
    function factoryFunction($resource, $rootScope) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/seeker/api/lookups/occupations/compare/:code1/:code2';
        return $resource(resourceUrl, {}, {
            get: {
                method: 'GET', isArray: false
            }
        });
    };

})();




(function () {
    'use strict';

    angular.module('globalApp').factory("getOccupationDetails", ['$resource', '$rootScope', factoryFunction]);
    
    function factoryFunction($resource, $rootScope) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/seeker/api/lookups/occupations/:code';
        return $resource(resourceUrl, {}, {
            get: {
                method: 'GET', isArray: false
            }
        });
    };

})();




(function () {
    'use strict';

    angular.module('globalApp').factory("getOccupationByIndustryCode", ['$resource', '$rootScope', 'cacheService', factoryFunction]);
    
    function factoryFunction($resource, $rootScope, cacheService) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/seeker/api/lookups/occupations/industries/:industryCode/occupations?sortOrder=:sortOrder';
        //var cache = cacheService.provider($rootScope.productVariables.caching.cacheTypesEnum.httpSharedCache).cache;
        return $resource(resourceUrl, {}, {
            get: {
                method: 'GET', isArray: true, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false }
        });
    };
})();



(function () {
    'use strict';

    angular.module('globalApp').factory("channelConfig", ['$resource', '$rootScope', factoryFunction]);
    
    function factoryFunction($resource, $rootScope) {
        var resourceUrl = $rootScope.productVariables.rootUrl + "/core/api/config/channel-configs/by-alias";
        return $resource(resourceUrl, {}, {
            post: { method: 'POST', isArray: true, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false },
            get: { url: resourceUrl + '/:alias', method: 'GET', isArray: false, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false }
        });
    };
})();


(function () {
    'use strict';

    angular.module('globalApp').factory("getMessage", ['$resource', '$rootScope', factoryFunction]);
    
    function factoryFunction($resource, $rootScope) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/core/api/config/messages';
        return $resource(resourceUrl, {}, {
            post: { method: 'POST', isArray: false, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false }
        });
    };
})();


(function () {
    'use strict';

    angular.module('globalApp').factory('httpInterceptor', ['$q', '$rootScope', 'authenticationStorage', 'registry', '$window', factoryFunction])
        .config(['$httpProvider', configFunction]);
            
    function factoryFunction($q, $rootScope, authenticationStorage, registry, $window) {
        return {
            request: function (config) {
                if (config.url.indexOf($rootScope.productVariables.serviceHost) >= 0) {
                    config.headers['ChannelID'] = $rootScope.productVariables.ChannelID;
                    config.headers['AppID'] = $rootScope.productVariables.ApplicationID;

                    //console.log(config);

                    var token = authenticationStorage.getToken();
                    if (token) {
                        config.headers['Authorization'] = 'Bearer ' + token;
                    }
                }
                return config;
            },
            responseError: function (response) {
                // globaly handel a 500 error

                // this will show all errors at the top of the screen.
                if (!$rootScope.topErrorList) { $rootScope.topErrorList = [] };
                var tempErrorString = response.status + ' : ' + response.statusText + ' ===> ' + response.config.url;
                $rootScope.topErrorList.push({ text: tempErrorString, type: 'alert-danger' });


                if (response.status == 500) {
                    registry.set('PageErrors', '500Error', response , 'sessionStorage');
                    $window.location.href = '/error';
                }

                if (response.config.url.indexOf($rootScope.productVariables.serviceHost) >= 0 &&
                (response.status === 401 || response.status === 403)) {
                    authenticationStorage.clear();



                }
                return $q.reject(response);
            }
        };
    };

    function configFunction($httpProvider) {
        $httpProvider.interceptors.push('httpInterceptor');
    };


})();
(function (angular) {
    'use strict';

    angular.module('globalApp').factory('trackFactory', ['$resource', '$rootScope', factoryFunction]);

    function factoryFunction($resource, $rootScope) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/core/api/config/tracking-configs';
          
        return $resource(resourceUrl, {}, {
            getTrackingConfigs: { method: 'GET', isArray: true, cache: false }
        });
    };

})(angular);
(function () {
    'use strict';

    angular.module('globalApp').factory("UserAccount", ['$resource', '$rootScope', factoryFunction]);
    
    function factoryFunction($resource, $rootScope) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/seeker/api/me/';
        return $resource(resourceUrl, {}, {
            get: { method: 'GET', isArray: false, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false },
            post: { method: 'POST', isArray: false, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false },
            put: { method: 'PUT', isArray: false, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false }
        });
    };

})();


(function () {
    'use strict';

    angular.module('globalApp').factory('agentsFactory', ['$resource', '$rootScope', factoryFunction]);

    function factoryFunction($resource, $rootScope) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/seeker/api/me/agents';
        var factory = $resource(resourceUrl, null,
            {
                'getAll': { method: 'GET', isArray: false },
                'delete': {
                    url: resourceUrl + '/:agentID',
                    params: { agentID: '@agentID' },
                    method: 'DELETE'
                },
                'getAgent': {
                    url: resourceUrl + '/:agentID',
                    params: { agentID: '@agentID' },
                    method: 'GET'
                },
                'updateAgent': {
                    method: 'POST'
                }
            }
        );
        return factory;
    };


})();
(function () {
    'use strict';

    angular.module('globalApp').factory('applicationHistory', ['$resource', '$rootScope', factoryFunction]);

    function factoryFunction($resource, $rootScope) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/seeker/api/me/applications';
        var factory = $resource(resourceUrl, null, {
                        
                get: {                    
                    method: 'GET',
                    isArray: false
                },
                saveCloudApplication: {
                    url: resourceUrl + '/cloud/:jobId',
                    params: { jobId: '@jobId' },
                    method: 'POST'
                },
                saveCoreApplication: {
                    url: resourceUrl + '/core/:jobId',
                    params: { jobId: '@jobId' },
                    method: 'POST'
                }
        });
        return factory;
    };

})();
(function () {
    'use strict';

    angular.module('globalApp').factory('careerPersonalityFactory', ['$resource', '$rootScope', factoryFunction]);

    function factoryFunction($resource, $rootScope) {

        var resourceUrl = $rootScope.productVariables.rootUrl + '/seeker/api/queries/career-personality-survey';
        var factory = $resource(resourceUrl, null, {
            getQuestions: {
                url: resourceUrl + '/questions',
                method: 'GET',
                isArray: true
            },
            getAnswerTypes: {
                url: resourceUrl + '/answers',
                method: 'GET',
                isArray: true
            },
            scoreAnswers: {
                url: resourceUrl,
                method: 'POST',
                isArray: true
            },
            getAnswers: {
                url: $rootScope.productVariables.rootUrl + '/seeker/api/me/career-personality-survey',
                method: 'GET',
                isArray: true
            },
            saveAnswersAndScore: {
                url: $rootScope.productVariables.rootUrl + '/seeker/api/me/career-personality-survey',
                method: 'POST',
                isArray: true
            }
        });
        return factory;
    };

})();
(function () {
    'use strict';

    angular.module('globalApp').factory('careerPlan', ['$resource', '$rootScope', factoryFunction]);

    function factoryFunction($resource, $rootScope) {
        var resourceUrl = $rootScope.productVariables.rootUrl + "/seeker/api/me/career-plan/goals";

        var factory = $resource(resourceUrl, null,
            {
                getGoals: {
                    url: resourceUrl,
                    method: 'GET'
                },
                getGoal: {
                    url: resourceUrl + '/:goalId',
                    params: { goalId: '@goalId' },
                    method: 'GET'
                },
                createGoal: {
                    url: resourceUrl,
                    method: 'POST'
                },
                updateGoal: {
                    url: resourceUrl + '/:goalId',
                    method: 'PUT'
                },
                deleteGoal: {
                    url: resourceUrl + '/:goalId',
                    params: { goalId: '@goalId' },
                    method: 'DELETE'
                },
                createActivities: {
                    url: resourceUrl + '/:goalId/activities',
                    params: { goalId: '@goalId', allActivitiesIncluded: '@allActivitiesIncluded' },
                    method: 'POST'
                },
                updateActivities: {
                    url: resourceUrl + '/:goalId/activities/:activityId',
                    params: { goalId: '@goalId', activityId: '@activityId' },
                    method: 'PUT'
                },
                removeActivity: {
                    url: resourceUrl + '/:goalId/activities/:activityId',
                    params: { goalId: '@goalId' , activityId: '@activityId'},
                    method: 'DELETE'
                }
            });
        return factory;
    };
})();

(function () {
    'use strict';

    angular.module('globalApp').factory('ContactUs', ['$resource', '$rootScope', factoryFunction]);

    function factoryFunction($resource, $rootScope) {
        var resourceUrl = $rootScope.productVariables.rootUrl + "/seeker/api/contact-us";
        return $resource(resourceUrl, {}, {
            put: { method: 'PUT', isArray: false, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false }
        });
    }

})();
(function () {
    'use strict';

    angular.module('globalApp').factory('coverLetters', ['$resource', '$rootScope', coverLettersFactory]);

    function coverLettersFactory($resource, $rootScope) {

        var resourceUrl = $rootScope.productVariables.rootUrl + '/seeker/api/me/coverletters';
        var factory = $resource(resourceUrl + '/:coverLetterId', { coverLetterId: '@coverLetterId' }, {            
            templates: {
                url: resourceUrl + '/templates',
                method: 'GET',
                isArray: true,
            },
            update: {
                method: 'PUT'
            },
            clone: {
                url: resourceUrl + '/:coverLetterId/clone',
                params: {coverLetterId: '@coverLetterId'},
                method: 'POST'
            },
            sendLetter: {
                url: resourceUrl + '/:coverLetterId/sendemail',
                params: { coverLetterId: '@coverLetterId' },
                method: 'POST'
            }
        });
        return factory;
    };

})();
(function() {
    "use strict";

    angular.module('globalApp').factory('documentUpload', ['$resource', '$rootScope', factoryFunction]);

    function factoryFunction($resource, $rootScope) {
        var resourceUrl;
        if ($rootScope.productVariables.ChannelID === 10429) {
            resourceUrl = $rootScope.productVariables.rootUrl + '/trainer/api/me/documents';
        } else {
            resourceUrl = $rootScope.productVariables.rootUrl + '/seeker/api/me/documents';
        }
         
        var factory = $resource(resourceUrl + '/:documentId', { documentId: '@documentId' }, {
            query: {
                method: 'GET',
                url: resourceUrl,
                params: { referenceType: '@referenceType', referenceValue: '@referenceValue' },
                isArray: true
            },
            download: {
                method: 'GET',
                url: resourceUrl + '/:documentId/download',
                params: { documentId: '@documentId' },
                //headers: {
                //    accept: '*/*' //todo- we might restrict the accepted mime types
                //},
                responseType: 'arraybuffer',
                cache: false,
                transformResponse: function(data, headers) {
                    var blob = null;
                    if (data) {
                        blob = new Blob([data], {
                            type: headers('content-type') || 'application/octet-stream'
                        });
                    }
                     
                    var fileName = getFileNameFromHeader(headers('content-disposition'));
                    var result = {
                        blob: blob,
                        fileName: fileName
                    };
 
                    return {
                        response: result
                    };
                }
            },
            uploadFromCloud: {
                method: 'POST',
                url: resourceUrl + '/uploadFromCloud'
            }
        });
        return factory;        
    };

    function getFileNameFromHeader(header) {
        if (!header) return null;
        var result = header.split(";")[1].trim().split("=")[1];
        return result.replace(/"/g, '');
    }

})();
(function () {
    'use strict';

    angular.module('globalApp').factory('eeoAa', ['$resource', '$rootScope', factoryFunction]);

    function factoryFunction($resource, $rootScope) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/seeker/api/me/applications/eeoaa/';
        var factory = $resource(resourceUrl, null, {
                get: {
                    url: resourceUrl + ':jobId',
                    params: { jobId: '@jobId' },
                    method: 'GET'
                }
        });
        return factory;
    };

})();
(function () {
    "use strict";
    angular.module('globalApp').factory('events', ['$resource', '$rootScope', factoryFunction]);

    function factoryFunction($resource, $rootScope) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/seeker/api/queries/public-events';
        var factory = $resource(resourceUrl, {}, {
            query: {
                method: 'POST',
                url: $rootScope.productVariables.rootUrl + '/seeker/api/queries/public-events',
                isArray: false
            },
            register: {
                method: 'PUT',
                url: $rootScope.productVariables.rootUrl + '/seeker/api/me/public-events/:eventId',
                params: { eventId: '@eventId' },
            },
            unregister: {
                method: 'DELETE',
                url: $rootScope.productVariables.rootUrl + '/seeker/api/me/public-events/:eventId',
                params: { eventId: '@eventId' },
            }
        });
        return factory;
    };
})();
(function () {
    'use strict';

    angular.module('globalApp').factory('jobSearchFactory', ['$resource', '$rootScope', factoryFunction]);

    function factoryFunction($resource, $rootScope) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/seeker/api/queries/jobsearch';
        var factory = $resource(resourceUrl, null,{
                'search': { method: 'POST' },
                'createAgent': { method: 'PUT', url: $rootScope.productVariables.rootUrl + '/seeker/api/me/agents' },
                'recommendedJobs': { method: 'POST', url: $rootScope.productVariables.rootUrl + '/seeker/api/me/recommended-jobs', isArray: true }
            }
        );
        return factory;
    };

})();
(function () {
    'use strict';

    angular.module('globalApp').factory('jobViewFactory', ['$resource', '$rootScope', factoryFunction]);
    
    function factoryFunction($resource, $rootScope) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/seeker/api/jobs';
        var factory = $resource(resourceUrl, {}, {
            getJob: {
                url: resourceUrl + '/:type/:id',
                params: { id: '@id', type: '@type' },
                method: 'GET'
            }
        });
        return factory;
    };

})(); 
(function () {
    'use strict';

    angular.module('globalApp').factory('optOutAgentsFactory', ['$resource', '$rootScope', factoryFunction]);

    function factoryFunction($resource, $rootScope) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/seeker/api/optout/agents';
        return $resource(resourceUrl, {}, {
            put: { method: 'PUT', isArray: false, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false }
        });
    };

})();
(function () {
    'use strict';

    angular.module('globalApp').factory('resumesFactory', ['$resource', '$rootScope', factoryFunction]);

    function factoryFunction($resource, $rootScope) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/seeker/api/me/resumes';
        var factory = $resource(resourceUrl, null,
            {
                'getResumes': { method: 'GET' },
                'getResumesForApplication': {
                    url: resourceUrl + '?forApplicationOnPositionAdID=:positionAdID',
                    params: { positionAdID: '@positionAdID' },
                    method: 'GET'
                },
                'delete': {
                    url: resourceUrl + '/:resumeValue/delete',
                    params: { resumeValue: '@resumeValue' },
                    method: 'POST',
                    isArray: true
                },
                'createResume': {
                    url: resourceUrl,
                    method: 'POST'
                },
                'copy': {
                    url: resourceUrl + '/:resumeValue/copy',
                    params: { resumeValue: '@resumeValue' },
                    method: 'POST'
                },
                'statusChange': {
                    url: resourceUrl + '/:resumeValue/status/:status',
                    params: { resumeValue: '@resumeValue', status: '@status' },
                    method: 'POST'
                },
                'send': {
                    url: resourceUrl + '/send',
                    method: 'PUT',
                    isArray: false,
                    requestType: 'json',
                    responseType: 'json',
                    contentType: "json/application"
                },
                'getResumeRating': {
                    url: resourceUrl + '/:resumeValue/getRating',
                    params: { resumeValue: '@resumeValue' },
                    method: 'GET'
                },
                'getResumePdfNumOfPages': {
                    url: resourceUrl + '/:resumeValue/pdf-resume-pageNo',
                    params: { resumeValue: '@resumeValue' },
                    method: 'GET'
                },
                'getResumePdfPageAsImage': {
                    url: resourceUrl + '/:resumeValue/pdfresume/:pageNo',
                    params: { resumeValue: '@resumeValue', pageNo: '@pageNo' },
                    method: 'GET',
                    responseType: 'arraybuffer',
                    isArray: false
                },
                'getResume': {
                    url: resourceUrl + '/:resumeValue?levelOfDetail=:levelOfDetail',
                    params: { resumeValue: '@resumeValue', levelOfDetail: '@levelOfDetail' },
                    method: 'GET'
                },
                'updateResume': {
                    url: resourceUrl + '/:resumeValue',
                    params: { resumeValue: '@resumeValue' },
                    method: 'PUT'
                },
                'validateCompletness': {
                    url: $rootScope.productVariables.rootUrl + '/seeker/api/me/validate-completness-for-create-resume',
                    method: 'POST',
                    isArray: true
                },
                'save': {
                    url: resourceUrl + '/:resumeValue/generateworddoc',
                    params: { resumeValue: '@resumeValue' },
                    method: 'GET',
                    responseType: 'arraybuffer',
                    cache: false,
                    transformResponse: function (data, headers) {
                        var blob = null;
                        if (data) {
                            blob = new Blob([data], {
                                type: headers('content-type') || 'application/msword; charset=utf-8'
                            });
                        }
                        var fileName = getFileNameFromHeader(headers('content-disposition'));
                        var result = {
                            blob: blob,
                            fileName: fileName
                        };

                        return {
                            response: result
                        };
                    }
                }

            }
        );
        return factory;
    };

    function getFileNameFromHeader(header) {
        if (!header) return null;
        var result = header.split(";")[1].trim().split("=")[1];
        return result.replace(/"/g, '');
    }

})();
(function () {
    'use strict';

    angular.module('globalApp').factory('savedJobsFactory', ['$resource', '$rootScope', factoryFunction]);

    function factoryFunction($resource, $rootScope) {

        var resourceUrl = $rootScope.productVariables.rootUrl + '/seeker/api/me/jobs';
        var factory = $resource(resourceUrl + '/:jobId', {jobId: '@jobId' }, {
            templates: {
                url: resourceUrl,
                method: 'GET',
                isArray: true
            },
            saveJob: {
                url: resourceUrl + '/:jobType/:jobId',
                params: { jobId: '@jobId', jobType: '@jobType' },
                method: 'POST'
            },
            delete: {
                url: resourceUrl + '/:source/:jobId/delete',
                params: { jobId: '@jobId', source: '@source' },
                method: 'POST'
            }
        });
        return factory;
    };

})();
(function () {
    'use strict';

    angular.module('globalApp').factory('savedOccupationsFactory', ['$resource', '$rootScope', factoryFunction]);

    function factoryFunction($resource, $rootScope) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/seeker/api/me/occupations';
        var factory = $resource(resourceUrl, null,
            {
                'get': { method: 'GET', isArray: true },
                'delete': {
                    url: resourceUrl + '/:code',
                    params: { code: '@code' },
                    method: 'DELETE'
                },
                'save': {
                    url: resourceUrl + '/:code',
                    params: { code: '@code' },
                    method: 'POST'
                }
            }
        );
        return factory;
    };

})();
(function () {
    'use strict';

    angular.module('globalApp').factory('schoolLookupFactory', ['$resource', '$rootScope', factoryFunction]);

    function factoryFunction($resource, $rootScope) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/seeker/api/lookups/occupations';
        var factory = $resource(resourceUrl, null,
            {
                'getSchool': {
                    url: resourceUrl + '/:occupationCode/schools/:schoolId',
                    params: { schoolId: '@schoolId', occupationCode: '@occupationCode' },
                    method: 'GET'
                },
                'getSchools': {
                    url: resourceUrl + '/:occupationCode/schools',
                    params: { occupationCode: '@occupationCode' },
                    method: 'GET',
                    isArray: false
                }

            }
        );
        return factory;
    };

})();
(function () {
    'use strict';

    angular.module('globalApp').factory('schoolsFactory', ['$resource', '$rootScope', factoryFunction]);
    
    function factoryFunction($resource, $rootScope) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/seeker/api/me/schools';

        var factory = $resource(resourceUrl, null,
            {
                'get': { method: 'GET', isArray: true },
                'delete': {
                    url: resourceUrl + '/:schoolId/:programId',
                    params: { schoolId: '@schoolId', programId : '@programId'},
                    method: 'DELETE'
                },
                'save': {
                    url: resourceUrl + '/:occupationCode/:schoolId/:programId',
                    params: {occupationCode: '@occupationCode', schoolId: '@schoolId', programId: '@programId' },
                    method: 'POST'
                }
            }
        );
        return factory;
    };

})();
(function () {
    'use strict';

    globalApp.factory("sendJobEmailFactory", ['$resource', '$rootScope', factoryFunction]);
    
    function factoryFunction($resource, $rootScope) {
        var resourceUrl = $rootScope.productVariables.rootUrl + '/seeker/api/me/send-job-to-friend';
        return $resource(resourceUrl, {}, {
            post: { method: 'POST', isArray: false, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false }
        });
    };

})();

(function () {
    'use strict';

    angular.module('globalApp').factory('UserAudit', ['$resource', '$rootScope', '$q', factory]);

    function factory($resource, $rootScope, $q) {
        var resourceUrl = $rootScope.productVariables.rootUrl + "/seeker/api/me/";
        return $resource(resourceUrl, null,
             {
                 getHistory: {
                     url: resourceUrl + 'checklists',
                     method: 'POST',
                     isArray: true
                 },
                 getUserByEmail: {
                     url: resourceUrl + 'getbyemail?emailAddress=:emailAddress',
                     method: 'GET',
                     params: {
                         emailAddress: '@emailAddress'
                     }
                 }
             });
    };

})();


(function () {
    'use strict';
    globalApp.filter('capitalize', function () {
        return function (input) {
            return (!!input) ? input.split(' ').map(function (wrd) {
                return wrd.charAt(0).toUpperCase() + wrd.substr(1).toLowerCase();
            }).join(' ') : '';
        }
    });
})();
(function () {
    'use strict';

    globalApp.filter('startFrom', function () {
        return function (input, start) {
            if (!input || !input.length) { return; }
            start = +start; //parse to int
            return input.slice(start);
        }
    });
})();
//(function () {
    'use strict';
    angular.module('globalApp').filter('tel', function () {
        return function (tel) {
            if (!tel) { return ''; }

            var value = tel.toString().trim().replace(/^\+/, '');

            if (value.match(/[^0-9]/)) {
                return tel;
            }

            var country, city, number;

            switch (value.length) {
                case 10: // +1PPP####### -> C (PPP) ###-####
                    country = 1;
                    city = value.slice(0, 3);
                    number = value.slice(3);
                    break;

                case 11: // +CPPP####### -> CCC (PP) ###-####
                    country = value[0];
                    city = value.slice(1, 4);
                    number = value.slice(4);
                    break;

                case 12: // +CCCPP####### -> CCC (PP) ###-####
                    country = value.slice(0, 3);
                    city = value.slice(3, 5);
                    number = value.slice(5);
                    break;

                default:
                    return tel;
            }

            if (country == 1) {
                country = "";
            }

            number = number.slice(0, 3) + '-' + number.slice(3);

            return (country + " (" + city + ") " + number).trim();
        };
    });
//})();



(function () {
    'use strict';
    globalApp.filter('unsafe', ['$sce', function ($sce) {
        return function (val) {
            if (val) {
                val = val.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, " ");
                val = val.replace(/<embed\b[^<]*(?:(?!<\/embed>)<[^<]*)*<\/embed>/gi, " ");
                return $sce.trustAsHtml(val);
            }
        };
    }]);
})();

(function () {
    "use strict";
    angular.module('globalApp').controller('debugController', ['$scope', '$rootScope', 'utilityService', '$uibModal', 'registry', controller]);

    function controller($scope, $rootScope, utilityService, $uibModal, registry) {
        if (!$rootScope.login) {
            $rootScope.login = { boxOpen: false };
        }

        $scope.bringMobileMenu = function () {
            $rootScope.sideMenuOpened = ($rootScope.sideMenuOpened) ? false : true;
        };

        $scope.originalMessagesOn = true;

        $scope.toggleMessageDisplay = function () {

            $scope.originalMessagesOn = !$scope.originalMessagesOn;

            if ($scope.originalMessagesOn) {
                $rootScope.preResolvePhase($rootScope.meta, $rootScope.messages).then(function () {
                    $rootScope.$broadcast('$$rebind::preResolved');
                    if (!$rootScope.$$phase) {
                        $rootScope.$digest();
                    }
                });
            }
            else {
                switchMeta($rootScope.meta);
                switchServerMessages($rootScope.serverMessagesObj);

                $rootScope.$broadcast('$$rebind::preResolved');
                if (!$rootScope.$$phase) {
                    $rootScope.$digest();
                }
            }
        };

        function switchMeta(j) {
            var changes = [];
            utilityService.forEach(j, function (obj) {
                if (obj && typeof obj.lookUpMsg === 'object') {
                    changes.push(obj.lookUpMsg);
                }
            });
            angular.forEach(changes, function (lookUpMsg) {
                var id = lookUpMsg.id;
                lookUpMsg.value = '[' + id + ']';
            });
        };


        function switchServerMessages(j) {
            var x = 0;
            for (x in j) {
                var id = j[x].id;
                j[x].text = '[' + id + ']';
            }
        };




        // registry model launch code
        $scope.openRegistryModal = function () {
            var modalInstance = $uibModal.open({
                backdrop: 'static',
                keyboard: false,
                templateUrl: 'headerRegistryModal.html',
                controller: 'ModalInstanceCtrl',
                size: 'lg'
            });
            modalInstance.result.then(purge);
            function purge() {
                registry.purge();
                return
            }
        }
    }
})();
(function () {
    "use strict";
    angular.module('globalApp').controller('footerController', ['$scope', '$rootScope', '$uibModal', controller]);

    function controller($scope, $rootScope, $uibModal, registry) {
        $scope.currentYear = new Date().getFullYear();
        $scope.version = $rootScope.registry.localStore.global.context.Version;

        //var modalInstance = $uibModal.open({
        //    backdrop: 'static',
        //    keyboard: false,
        //    templateUrl: 'communicationError.html',
        //    controller: 'ModalInstanceCtrl',
        //    size: 'sm'
        //});


    }

})();
(function () {
    "use strict";
    angular.module('globalApp').controller('LoginController', loginController);

    loginController.$inject = ['$scope', '$rootScope', '$httpParamSerializer', 'authentication', 'authenticationStorage', '$uibModal', '$window', '$timeout', '$location', '$http', '$cookies'];
    function loginController($scope, $rootScope, $httpParamSerializer, authentication, authenticationStorage, $uibModal, $window, $timeout, $location, $http, $cookies) {

        $scope.user = {};
        $scope.loginType = 'seeker';
        $scope.error = "";

        $scope.logout = function () {
            if (authentication.isAuthenticatingUsingSaml()) {
                $scope.samlLogout();
            } else {
                authentication.logout();
                $window.location.href = "/";
            }
        };

        $scope.login = function () {
            if (authentication.isAuthenticatingUsingSaml()) {
                $scope.samlLogin();
            }
            else {
                $window.location.href = "/login";
            }
        }
                 
        $scope.isAuthenticated = function () {
            if (authentication.isAuthenticatingUsingSaml()) {
                return isAuthenticatedAtIdpAndLocally();
            }
            return authentication.isAuthenticated();
        };

        $scope.getFullName = function () {
            if (authenticationStorage.getUser() !== null) {
                var user = authenticationStorage.getUser();
                return user.firstName + " " + user.lastName;
            }
        };

        $scope.getUserEmail = function () {
            if (authenticationStorage.getUser() !== null) {
                var user = authenticationStorage.getUser();
                return user.emailAddress;
            }
        };

        $scope.loginBoxToggle = function (open) {
            // clean callout if there was any if user choose to close login box
            if (!$rootScope.login.boxOpen) {
                $rootScope.login.callout = null;
            }
        }

        $scope.createAccount = function ($event) {
            var location = '/account#/?' + $httpParamSerializer({ callout: { type: 'redirect', data: $location.absUrl() } });
            if ($rootScope.login.callout) {
                location = '/account#/?' + $httpParamSerializer({ callout: $rootScope.login.callout });
            }
            $window.location = location;
            $event.preventDefault();
            $event.stopPropagation();
        };

        $scope.applyModel = function (e) {
            $scope.loginType = e.loginType;
            $scope.user.isBusy = false;
            $scope.error = "";
            $scope.loginForm.$setPristine();
        }

        $scope.samlLogout = function (e) {
            $window.location.href = '/saml/redirect/sloresponse?ReturnUrl=' + $window.encodeURIComponent("/samllogout");
        }

        $scope.samlLogin = function (e) {
            $window.location.href = '/saml/signin?ReturnUrl=' + $window.encodeURIComponent($window.location.href);
        }

        function isSeeker() {
            return $scope.loginType === 'seeker';
        }

        function isAuthenticatedAtIdp() {
            var authCookieName = authenticationStorage.getIdpAuthCookieName();
            var idpAuthCookie = $cookies.get(authCookieName);

            return (idpAuthCookie != null);
        }

        function isAuthenticatedAtIdpAndLocally() {
            if (isAuthenticatedAtIdp()) {
                if (authentication.isAuthenticated()) {
                    return true;    //authenticated locally and at idp
                }
                else {
                    if ($scope.InitiatingSamlLogin == null) {
                        $scope.InitiatingSamlLogin = true;
                        console.log("Initiating a SAML login");
                        $scope.samlLogin();
                    }
                    return false;   //authenticated at idp but not locally
                }
            }
            return false;   //not authenticated at idp
        }

        $scope.go = function () {
            $scope.error = "";
            if ($scope.loginForm.$valid) {
                if (isSeeker()) {
                    authentication.login($scope.user.email, $scope.user.password).then(
                        function (result) {
                            $scope.user.isBusy = false;
                            if (result.success) {
                                $scope.error = "";
                                console.log(result);
                                if (result.url.indexOf("account") !== -1) {
                                    location.reload(true);
                                }
                            }
                            else {
                                $scope.error = $rootScope.msg(157552);
                            }
                        },
                        function (error) {
                            console.log(error);
                            $scope.error = error.data.message;
                        }
                    );
                }
                else {
                    $scope.error = "No employer login.";
                    $scope.user.isBusy = false;
                }
            }
        };
    }
})();
(function () {
    "use strict";
    function modalInstanceCtrl($scope, $uibModalInstance) {
        $scope.ok = function () {
            $uibModalInstance.close();
        };

        $scope.cancel = function () {
            $uibModalInstance.dismiss('cancel');
        };

        $scope.close = function () {
            $uibModalInstance.dismiss('close');
        };
    };

    modalInstanceCtrl.$inject = ['$scope', '$uibModalInstance'];
    angular.module('globalApp').controller('ModalInstanceCtrl', modalInstanceCtrl);
})();
(function () {
    angular.module('globalApp')
        .controller('SearchPanelController', ['$rootScope', '$scope', '$window', '$location', 'autoCompleteFactory', controller]);

    function controller($rootScope, $scope, $window, $location, autoCompleteFactory) {
        $rootScope.search = {
            location: $location.search().location,
            keywords: $location.search().keywords
        };

        $scope.search = function () {
            var location = $rootScope.search.location ? $rootScope.search.location : '';
            $rootScope.track({ name: 'jobSearch', location: location, keywords: $rootScope.search.keywords });
            if ($window.location.pathname == '/JobSearch') {
                // cool we're already there
                $location.search({ location: location, keywords: $rootScope.search.keywords });
            }
            else {
                var sBase = '/JobSearch#/jobs';
                var sChar = '?';
                if (location) {
                    sBase += sChar + 'location=' + encodeURIComponent(location);
                    sChar = '&';
                }
                if ($rootScope.search.keywords) {
                    sBase += sChar + 'keywords=' + encodeURIComponent($rootScope.search.keywords);
                }
                $window.location = sBase;
            }
        };


        $scope.remoteApiHandler = function (userInputString, timeoutPromise) {
            return autoCompleteFactory.locations({ countryId: 164, query: userInputString }, { timeout: timeoutPromise }).$promise;
        };

        $scope.responseFormatter = function (result) {
            var meta = $rootScope.meta.locationMeta;
            if (!meta) return result;


            //unwrap root node
            var itemsWrapper = meta.remoteItemsWrapper;
            var unwrappedData = itemsWrapper ? result[itemsWrapper] : result;

            //removes html tags from the input string
            function htmlToPlaintext(text) {
                return text ? String(text).replace(/<[^>]+>/gm, '') : '';
            }

            var mappedData = [];
            var textField = meta.titlefield;
            var valueField = meta.valuefield;

            //remove html tags
            angular.forEach(unwrappedData, function (value, key) {
                mappedData.push({ id: value[valueField], text: htmlToPlaintext(value[textField]) });
            }, mappedData);

            

            return mappedData;
        };
    }
})();



(function () {
    'use strict';
    angular.module('globalApp').directive("ocs401", ['$rootScope', '$httpParamSerializer', '$location', '$window', 'templateUrlService', 'authentication', directiveFunction]);

    function directiveFunction($rootScope, $httpParamSerializer, $location, $window, templateUrlService, authentication) {
        return {
            restrict: "E",
            scope: {
                meta: "=",
            },
            templateUrl: (!authentication.isAuthenticatingUsingSaml()) ? templateUrlService.get('ocs-401.html') : "",
            link: function (scope) {

                if (authentication.isAuthenticatingUsingSaml() && !authentication.isAuthenticated()) {
                    $window.location.href = '/saml/signin?ReturnUrl=' + $window.encodeURIComponent($window.location.href);
                }

                scope.createAccount = function () {
                    var location = '/account#/?' + $httpParamSerializer({ callout: { type: 'redirect', data: $location.absUrl() } });
                    if ($rootScope.login && $rootScope.login.callout) {
                        location = '/account#/?' + $httpParamSerializer({ callout: $rootScope.login.callout });
                    }
                    $window.location = location;
                };
            }
        };
    };

})();
(function () {
    'use strict';
    angular.module('globalApp').directive("ocsAccordionSteps", ['$rootScope', 'templateUrlService', directiveFunction]);

    function directiveFunction($rootScope, templateUrlService) {
        return {
            restrict: "E",
            scope: {
                meta: "=",
                model: "=",
                configLayout: "=",
                accordionName: '='
            },
            templateUrl: templateUrlService.get('ocs-AccordionSteps.html'),
            replace: true,
            transclude: true,
            link: function (scope, element, attrs) {

                var getActiveStep = function (accordionMeta) {
                    var steps = new Array();
                    var onStep = 0;
                    for (var m in accordionMeta) {
                        if (accordionMeta[m].configShow == true && accordionMeta[m].show == true) {
                            steps.push(m);
                        }
                    }
                    for (var x = 0; x < steps.length - 1; x++) {
                        if (accordionMeta[steps[x]].isOpen == true) {
                            onStep = steps[x + 1];
                            break;
                        }
                    }

                    return onStep;
                }

                var setActiveStep = function (makeActive, accordionMeta) {
                    for (var m in accordionMeta) {
                        if (accordionMeta[m]) {
                            accordionMeta[m].isOpen = false;
                            accordionMeta[m].isdisabled = false;
                            accordionMeta[m].cssClass = false;
                            accordionMeta[m].curentActive = false;

                        }
                    }
                    if (accordionMeta[makeActive]) {
                        accordionMeta[makeActive].isOpen = true;
                        accordionMeta[makeActive].isOpen = true;
                        accordionMeta[makeActive].isDisabled = false;
                        accordionMeta[makeActive].curentActive = true;
                    }
                }

                scope.stepIndex = function (key) {
                    var index = 0;
                    for(var x in scope.meta[scope.accordionName])
                    {
                        if (scope.meta[scope.accordionName][x].show)
                        {
                            index++;
                        }
                        if (x === key)
                        {
                            return index;
                        }
                    }
                    return 0;
                };

                scope.moveToNextSection = function (clickedFrom, accordionMeta) {
                    accordionMeta[clickedFrom].touched = true;

                    var currentActive = getActiveStep(accordionMeta);
                    var steps = new Array();
                    var rememberNextOne = false;
                    for (var m in accordionMeta) {
                        if (m == currentActive) {
                            var nextOne = m;
                            break;
                        }
                    }

                    if (clickedFrom == 'userVerification' && nextOne === undefined) {
                        nextOne = 'loginInformation';
                    }

                    if (!accordionMeta[clickedFrom].onNextStepWait) {
                        // run the extra function if it exsists
                        if (accordionMeta[clickedFrom].fn) {
                            accordionMeta[clickedFrom].fn();
                        }
                        // move focus to the next one on the page
                        setActiveStep(nextOne, accordionMeta);
                    }

                    if (accordionMeta[clickedFrom].onNextStepWait) {
                        
                        // run the extra function if it exsists
                        if (accordionMeta[clickedFrom].fn) {
                            var promise = accordionMeta[clickedFrom].fn();
                            promise.then(function () {
                                //go to next step
                                setActiveStep(nextOne, accordionMeta);
                            }, function () {
                                //stay on current step
                            });
                        }
                    }

                }

                scope.initSteps = function (accordionMeta) {
                    var makeActive = getActiveStep(accordionMeta);
                    setActiveStep(makeActive, accordionMeta);
                    for (var m in accordionMeta) {
                        var formName = 'globalForm' + accordionMeta[m].formName + '.$valid';
                    }
                }
            }
        };
    };

})();

(function (angular) {
    'use strict';
    angular.module('globalApp').directive("ocsAlert", ['$rootScope', 'templateUrlService', directiveFunction]);

    function directiveFunction($rootScope, templateUrlService) {
        return {
            restrict: "E",
            scope: {
                meta: "=",
            },
            templateUrl: templateUrlService.get('ocs-Alert.html'),
            controller: ['$rootScope', '$scope', function ($rootScope, $scope) {
                $scope.impersonationAlert = '';
                $rootScope.$watch("impersonation.emailAddress", function () { updateImpersonationAlert($scope); });
                $rootScope.$watch("meta.alerts.impersonation.lookUpMsg.value", function () { updateImpersonationAlert($scope); });
            }]
        };

        function updateImpersonationAlert($scope)
        {
            var format = $rootScope.meta.alerts.impersonation.lookUpMsg.value;
            var email = null;
            if ($rootScope.impersonation)
            {
                email = $rootScope.impersonation.emailAddress;
            }
            if (format) {
                $scope.impersonationAlert = format.format(email);
            }
        }

    };

})(angular);

(function () {
    'use strict';
    angular.module('globalApp').directive('ocsApplyNotify', ['$parse', '$rootScope', '$timeout', 'templateUrlService', 'registry', directiveFunction]);

    function directiveFunction($parse, $rootScope, $timeout, templateUrlService, registry) {
        return {
            restrict: 'E',
            templateUrl: templateUrlService.get('ocs-ApplyNotify.html'),
            scope: {
                meta: "=",
            },
            link: function (scope, element, attrs) {
                scope.show = false;
                var apply = registry.get('global', 'currentApply', 'sessionStorage');

                if (apply && apply.id > 0 && window.location.href.indexOf('/apply') == -1 && $rootScope.isAuthenticated) {
                    scope.show = true;
                    scope.job = apply;
                }

                scope.cancel = function () {
                    scope.show = false;
                    scope.job = {};
                    registry.remove('global', 'currentApply', 'sessionStorage');
                    registry.remove('global', 'currentApplyState', 'sessionStorage');
                    window.location = '/#';
                }

                scope.finish = function () {
                    window.location = scope.job.url;
                }
            }
        };
    };

})();

(function () {
    'use strict';
    angular.module('globalApp').directive("ocsAutocomplete", ['$rootScope', '$parse', 'templateUrlService', directiveFunction]);

    function directiveFunction($rootScope, $parse, templateUrlService) {
        return {
            restrict: "E",
            scope: {
                meta: "=",
                model: "=",
                searchString: "=",
                remoteApiHandler: "=",
                remoteResponseFormatter: "=",
                inputClass: "@",
                customValidatorStates: "=",
                onInputChanged: '=',
                tag: "@"
            },
            templateUrl: templateUrlService.get('ocs-AutoComplete.html'),
            controller: ["$scope", function ($scope) {
                // this incriments the global counter and creates a new uneque ID
                if ($rootScope.IdCounter == undefined) {
                    $rootScope.IdCounter = 0;
                }
                $scope.elimentId = "elem_" + $rootScope.IdCounter++;
            }],
            link: function (scope, elem, attrs) {
                //setting initialValue
                if (scope.searchString) {
                    scope.initialValue = scope.searchString;
                }

                //setting up the searchString value
                var setInputValue = function (inputValue) {
                    scope.searchString = inputValue;
                };

                scope.inputChanged = function (searchStr) {
                    setInputValue(searchStr);
                };

                scope.$watch("model", function (newValue) {
                    if (newValue && newValue.title) {
                        setInputValue(newValue.title);
                    }
                });

                scope.$watch("searchString", function (newValue, oldValue) {
                    if (newValue !== oldValue)
                    {
                        if (scope.onInputChanged) {
                            scope.onInputChanged(newValue, scope.tag);
                        }
                    }
                });

                //to add options
                if (attrs.options) {
                    var options = $parse(attrs.options)(scope);
                    if (options.class) {
                        elem.find('.form-group').addClass(options.class);
                    }
                }
                //lazy setting of the additional styles; this should overcome allignment issue on jobserach panel
                //elem.on('click', function(event) {
                //    if (scope.meta.dropdownStyle) {
                //        var dd = angular.element(document.querySelector('#' + scope.elimentId + '_dropdown'));
                //        if (dd) {
                //            dd.attr('style', scope.meta.dropdownStyle);
                //        }                            
                //    }
                //    elem.off('click');
                //});                    
            }

        };
    };

})();

(function () {
    'use strict';
    angular.module('globalApp').directive('ocsBarChart', ['$parse', '$rootScope', '$timeout', 'templateUrlService', directiveFunction]);

    function directiveFunction($parse, $rootScope, $timeout, templateUrlService) {
        return {
            restrict: 'E',
            templateUrl: templateUrlService.get('ocs-BarChart.html'),
            scope: {
                settings: '=',
            },
            link: function (scope, element, attrs) {
                scope.openAccordion = function (tab) {
                    // Load-bearing settimeout. if you it it without it,
                    // it tries to do another apply before the first one finishes
                    $timeout(function () {
                        $('[heading^="' + tab + '"] a').click();
                    });
                }

                scope.$on("barsRendered", function () {
                    var $bars = element.find('.progress-bar');
                    var counter = 0;
                    angular.forEach($bars, function (elem) {
                        $(elem).width(scope.settings[counter].value +'%');
                        counter++;
                    });
                });
                
            }
        };
    };

})();

(function ($) {
    'use strict'
    angular.module('globalApp').directive('ocsBindToButton', directiveFunction);

    function directiveFunction($timeout) {
        return {
            restrict: 'A',
            scope: {
                list: '@',
                validation: '=',
                trigger: '@'
            },
            link: link
        }

        function link(scope, elem, attr) {

            $timeout(bindInputs, 500);

            function bindTo(elem, button) {
                elem.on('keypress', function (e) {
                    if (event.keyCode === 13 && (scope.validation.$valid === true || scope.validation === undefined)) {
                        button.click();
                    }
                });
            }

            function bindInputs() {
                var bind = (scope.list) ? elem.find(scope.list) : elem.find('input');
                var trigger = elem.find(scope.trigger);
                for (var i = 0, length = bind.length; i < length; i += 1) {
                    bindTo(bind.eq(i), trigger);
                }
            }
        }
    }

})(jQuery);

(function () {
    "use strict";
    angular.module('globalApp').directive("ocsBreadCrumbs", ['templateUrlService', directiveFunction]);

    function directiveFunction(templateUrlService) {
        return {
            restrict: "E",
            scope: {
                meta: "=",
            },
            templateUrl: templateUrlService.get('ocs-BreadCrumbs.html'),
            //replace: true,
            transclude: false,
            link: function (scope, element, attrs) {
            }
        };
    };

})();

(function () {
    'use strict';
    angular.module('globalApp').directive('ocsButton', ['$timeout', '$parse', '$rootScope', 'templateUrlService', directiveFunction]);

    function directiveFunction($timeout, $parse, $rootScope, templateUrlService) {
        return {
            restrict: 'E',
            scope: {
                meta: "=",
                validation: "=",
                isBusy: "=?",
            },
            replace: true,
            templateUrl: templateUrlService.get('ocs-Button.html'),
            link: link
        };

        function link(scope, element, attrs) {
            var options = $parse(attrs['options'])(scope);
            var spinner = " <i class='fa fa-spinner fa-spin'></i>";
            var timer;

            scope.id = attrs.id;

            if (scope.isBusy !== undefined) {
                scope.isBusy = false;
            }

            if (options) {
                if (options.type === 'submit') {
                    element.attr('type', 'submit');
                }
                //to add clases from options
                element.addClass(options.classes);
            }

            //once async function resolves we update model isBusy
            scope.$watch(
                function () {
                    return scope.isBusy;
                },
                function handleAsync(newValue, oldValue) {
                    if (!angular.equals(newValue, oldValue) && scope.isBusy !== true) {
                        scope.isBusy = newValue;
                        element.find('i').remove();
                        $timeout.cancel(timer);      // cancels the button's on click timer
                    }
                });

            element.on('click', function (e) {       // creates timeout for fast responses to prevent flickering caused by the spinner element
                if(scope.meta.isBusy == false){      // prevents multiple clicks
                timer = $timeout(function () {
                    element.append(spinner);     // adds a spinner to the button
                }, 500);
                scope.$apply(function () {
                    scope.isBusy = true;
                });
                }
            });
        }
    };

})();


(function () {
    'use strict';

    var knownCategories = {
        CareerPlanGoal: "CareerPlanGoal",
        CareerPlanActivity: "CareerPlanActivity",
        CareerPlanRecommendedActivity: "CareerPlanRecommendedActivity",
        MonsterDbAppointment: "MonsterDbAppointment",
        Holiday: "Holiday",
        EtoRegisteredEvents: "EtoRegisteredEvents"
    };

    angular.module('globalApp').directive('ocsCalendar',
        ['$timeout', '$parse', '$window', '$rootScope', '$uibModal', 'authentication', 'careerPlan', 'templateUrlService', directiveFunction]);
    function directiveFunction($timeout, $parse, $window, $rootScope, $uibModal, authentication, careerPlan, templateUrlService) {
        return {
            restrict: 'E',
            scope: {
                meta: "="
            },
            replace: true,
            templateUrl: templateUrlService.get('ocs-Calendar.html'),
            controller: ['$scope', '$rootScope', '$resource', 'authentication', controller],
            link: function (scope, element, attrs) {
                if (scope.meta) {
                    if (scope.meta !== undefined && scope.meta.showLegend !== undefined)
                    {
                        scope.showLegend = scope.meta.showLegend;
                    }
                }
            }
        };

        function controller($scope, $rootScope, $resource, authentication) {
            if ($rootScope.IdCounter === undefined) {
                $rootScope.IdCounter = 0;
            }
            $scope.calendarId = $rootScope.IdCounter++;
            $scope.showLegend = true;
            $scope.isAuthenticated = authentication.isAuthenticated();
                
            $rootScope.$on('login_success', function () {
                $scope.isAuthenticated = true;
                $scope.dataSource.read();
            });

            $rootScope.$on('logout_success', function () {
                $scope.isAuthenticated = false;
                $scope.dataSource.read();
            });

            $scope.getScheduler = function () {
                return $scope['scheduler' + $scope.calendarId.toString()];
            };

            var now = new Date();
            var startTime = now;
            startTime.setHours(7);
            startTime.setMinutes(0);

            var resourceUrl = $rootScope.productVariables.rootUrl + '/seeker/api/me/events';
            var eventsCall = $resource(resourceUrl, {}, {
                post: { method: 'POST', isArray: false, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false },
                put: { method: 'PUT', isArray: false, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false }
            });
            var eventsDeleteCall = $resource(resourceUrl + '/delete', {}, {
                destroy: { method: 'POST', isArray: false, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false }
            });
            var legendEntriesCall = $resource($rootScope.productVariables.rootUrl + '/seeker/api/lookups/event-categories', {}, {
                get: { method: 'GET', isArray: true, requestType: 'json', responseType: 'json', contentType: "json/application", cache: false },
            });

            $scope.legendEntriesLoaded = false;
            $scope.legendEntries = [];

            $scope.dataSource = new kendo.data.SchedulerDataSource({
                batch: true,
                transport: {
                    read: function (options) {
                        if ($scope.legendEntriesLoaded) {
                            var scheduler = $scope.getScheduler();
                            var categories = [];
                            angular.forEach($scope.legendEntries, function (value) {
                                if (value.checked) {
                                    categories = categories.concat(value.categories);
                                }
                            });
                            eventsCall.post({
                                start: scheduler.view().startDate(),
                                end: scheduler.view().endDate(),
                                categories: categories
                            })
                            .$promise
                            .then(function (data) {
                                options.success(data);
                            }, function (data) {
                                options.error(data);
                            });
                        } else {
                            options.success([]);
                        }
                    },
                    update: function (options) {
                        var data = $scope.dataSource.data();
                        var models = [];
                        angular.forEach(data, function (item) {
                            if (item.dirty && item.taskId && item.taskId !== "") {
                                models.push(item);
                            }
                        });
                        wrapPromise(options, eventsCall.put({ models: models }));
                    },
                    create: function (options) {
                        var data = $scope.dataSource.data();
                        var models = [];
                        angular.forEach(data, function (item) {
                            if (item.taskId === undefined || item.taskId === null || item.taskId === "") {
                                models.push(item);
                            }
                        });
                        wrapPromise(options, eventsCall.put({ models: models }));
                    },
                    destroy: function (options) {
                        wrapPromise(options, eventsDeleteCall.destroy(options.data));
                    }
                },
                error: function (e) {
                    console.log(e);
                },
                /*
                parameterMap: function (options, operation) {
                    var result = options;
                    if (operation === "read") {
                            
                        var scheduler = $("#scheduler").data("kendoScheduler");
                
                        if ($('#newAppointment').length == 0) {
                            scheduler.wrapper.find('.k-scheduler-fullday')
                
                                .after('<li class="k-state-default"><a href="#" id="newAppointment" class="k-link">New appointment</a></li>');
                
                            $('#newAppointment').on('click', function (e) {
                                e.preventDefault();
                
                                var date = new Date();
                                var hour = date.getHours();
                                var minutes = date.getMinutes();
                                var day = date.getDate();
                                var month = date.getMonth() + 1;
                                var year = date.getFullYear();
                
                                var startHour = 0;
                                var endHour = 0;
                                var endHour = 0;
                                var endMinutes = 0;
                
                                var startAmpm = hour >= 12 ? 'PM' : 'AM';
                                var stopAmpm = hour + 1 == 24 ? 'AM' : 'PM';
                
                                hour = hour % 12;
                                hour = hour ? hour : 12;
                
                                if (minutes >= 30) {
                                    startHour = hour;
                                    startMinutes = 30;
                                    endHour = hour + 1;
                                    endMinutes = '00';
                                } else {
                                    startHour = hour;
                                    startMinutes = '00';
                                    endHour = hour;
                                    endMinutes = 30;
                                }
                
                                var startTime = month + "/" + day + "/" + year + " " + startHour + ":" + startMinutes + " " + startAmpm;
                                var endTime = month + "/" + day + "/" + year + " " + endHour + ":" + endMinutes + " " + stopAmpm;
                
                                scheduler.addEvent({ title: "No title", start: new Date(startTime), end: new Date(endTime) });
                
                            });
                
                        }
                
                        var categories = [];
                        $(".typeSelector input:checked").each(function () {
                            categories.push($(this).attr('appointmenttype'));
                        });
                
                        var result = {
                            start: $scope.scheduler.view().startDate(),
                            end: $scope.scheduler.view().endDate(),
                            //categories: categories
                        };
                
                        return kendo.stringify(result);
                    }
                    if (operation === "update" || operation === "create") {
                        var rc = result.models[0].Category;
                
                        if (rc === allowedCategory) {
                            return kendo.stringify(result);
                        }
                        //if (rc === 'CareerPlanGoal' || rc === 'CareerPlanActivity' || rc === 'CareerPlanRecommendedActivity') {
                            //window.location = '/careerplan/careerplan.aspx#/viewACareerPlan/goalId/' + result.models[0].ScopeID;
                        //}
                    }
                
                    return kendo.stringify(options);
                },*/
                serverFiltering: true,
                schema: {
                    data: "models",
                    model: {
                        id: "taskId",
                        fields: {
                            taskId: { from: "taskID", type: "String" },
                            title: { from: "title", defaultValue: "No title", validation: { required: true } },
                            start: { type: "date", from: "start" },
                            end: { type: "date", from: "end" },
                            startTimezone: { from: "startTimezone" },
                            endTimezone: { from: "endTimezone" },
                            description: { from: "description" },
                            recurrenceId: { from: "recurrenceID", type: "String" },
                            recurrenceRule: { from: "recurrenceRule" },
                            recurrenceException: { from: "recurrenceException" },
                            ownerId: { from: "ownerID", defaultValue: 1 },
                            isAllDay: { type: "boolean", from: "isAllDay" },
                            category: { type: "String", from: "category" },
                            eventDetailUrl: { type: "String", from: "eventDetailUrl" },
                            isMandatoryEvent: { type: "boolean", from: "isMandatoryEvent" },
                            isRegistrationRequired: { type: "boolean", from: "isRegistrationRequired" }
                        }
                    }
                }
            });

            $scope.rebind = function () {
                $scope.dataSource.read();
            };

            $scope.window = $window;

            $scope.confirmDelete = function (onSuccess) {
                var modalInstance = $uibModal.open({
                    animation: true,
                    backdrop: 'static',
                    keyboard: false,
                    //size: 'sm',
                    template:
"<div class=\"modal-header\">" +
"  <h3 class=\"modal-title\">{{ calendarMessages.confirmDeleteTitle }}</h3>" +
"</div>" +
"<div class=\"modal-body\">" +
"  <h4>{{ calendarMessages.confirmDeleteBody }}</h4>" +
'<div ng-repeat="a in calendarMessages.activities"> {{a}} </div> ' +
"</div>" +
"<div class=\"modal-footer\">" +
"  <button class=\"btn btn-primary pull-left\" type=\"button\" ng-click=\"window.location.href = '/careerPlan#/goal/' + goalId\">Edit</button>" +
"  <button class=\"btn btn-link\" type=\"button\" ng-click=\"cancel()\">Cancel</button>" +
"  <button class=\"btn btn-danger\" type=\"button\" ng-click=\"ok()\">Delete</button>" +
"</div>",
                    controller: 'ModalInstanceCtrl',
                    scope: $scope,
                    resolve: {
                    }
                }).result.then(function () {
                    onSuccess();
                });
            };

            function init() {
                legendEntriesCall.get().$promise.then(function (data) {
                    angular.forEach(data, function (value) {
                        value.checked = true;
                    });
                    $scope.legendEntries = data;
                    $scope.legendEntriesLoaded = true;

                    var resources = [];
                    angular.forEach($scope.legendEntries, function (legendEntry) {
                        angular.forEach(legendEntry.categories, function (category) {
                            resources.push({ text: legendEntry.name, color: legendEntry.color, value: category });
                        });
                    });

                    $scope.getScheduler().resources[0].dataSource.data(resources);
                    $scope.getScheduler().refresh();
                    $scope.dataSource.read();
                });

                    
            };

            $scope.calendarMessages = {
                confirmDeleteTitle: null,
                confirmDeleteBody: null
            };

            function wrapPromise(options, promise) {
                promise.$promise
                .then(function (data) {
                    options.success(data);
                }, function (data) {
                    options.error(data);
                });
            };

            $scope.schedulerOptions = {
                date: now,
                startTime: startTime,
                height: 600,
                views: [
                    "day",
                    { type: "week", selected: true },
                    "month",
                    "agenda",
                    "timeline"
                ],
                editable: {
                    confirmation: false
                },
                footer: false,
                //{
                //  command: false
                //},
                messages: {
                    today: $rootScope.meta.calendar.today.lookUpMsg.text,
                    pdf: $rootScope.meta.calendar.pdf.lookUpMsg.text,
                    save: $rootScope.meta.calendar.save.lookUpMsg.text,
                    cancel: $rootScope.meta.calendar.cancel.lookUpMsg.text,
                    destroy: $rootScope.meta.calendar.destroy.lookUpMsg.text,
                    deleteWindowTitle: $rootScope.meta.calendar.deleteWindowTitle.lookUpMsg.text,
                    ariaSlotLabel: $rootScope.meta.calendar.ariaSlotLabel.lookUpMsg.text,
                    ariaEventLabel: $rootScope.meta.calendar.ariaEventLabel.lookUpMsg.text,
                    views: {
                        day: $rootScope.meta.calendar.views.day.lookUpMsg.text,
                        week: $rootScope.meta.calendar.views.week.lookUpMsg.text,
                        agenda: $rootScope.meta.calendar.views.agenda.lookUpMsg.text,
                        month: $rootScope.meta.calendar.views.month.lookUpMsg.text,
                        timeline: $rootScope.meta.calendar.views.timeline.lookUpMsg.text,
                        timelineWeek: $rootScope.meta.calendar.views.timelineWeek.lookUpMsg.text,
                        timelineMonth: $rootScope.meta.calendar.views.timelineMonth.lookUpMsg.text
                    },
                    recurrenceMessages: {
                        deleteWindowTitle: $rootScope.meta.calendar.recurrenceMessages.deleteWindowTitle.lookUpMsg.text,
                        deleteWindowOccurrence: $rootScope.meta.calendar.recurrenceMessages.deleteWindowOccurrence.lookUpMsg.text,
                        deleteWindowSeries: $rootScope.meta.calendar.recurrenceMessages.deleteWindowSeries.lookUpMsg.text,
                        editWindowTitle: $rootScope.meta.calendar.recurrenceMessages.editWindowTitle.lookUpMsg.text,
                        editWindowOccurrence: $rootScope.meta.calendar.recurrenceMessages.editWindowOccurrence.lookUpMsg.text,
                        editWindowSeries: $rootScope.meta.calendar.recurrenceMessages.editWindowSeries.lookUpMsg.text
                    },
                    editable: { confirmation: $rootScope.meta.calendar.editable.confirmation.lookUpMsg.text },
                    editor: {
                        title: $rootScope.meta.calendar.editor.title.lookUpMsg.text,
                        start: $rootScope.meta.calendar.editor.start.lookUpMsg.text,
                        end: $rootScope.meta.calendar.editor.end.lookUpMsg.text,
                        allDayEvent: $rootScope.meta.calendar.editor.allDayEvent.lookUpMsg.text,
                        description: $rootScope.meta.calendar.editor.description.lookUpMsg.text,
                        repeat: $rootScope.meta.calendar.editor.repeat.lookUpMsg.text,
                        timezone: $rootScope.meta.calendar.editor.timezone.lookUpMsg.text,
                        startTimezone: $rootScope.meta.calendar.editor.startTimezone.lookUpMsg.text,
                        endTimezone: $rootScope.meta.calendar.editor.endTimezone.lookUpMsg.text,
                        separateTimezones: $rootScope.meta.calendar.editor.separateTimezones.lookUpMsg.text,
                        timezoneEditorTitle: $rootScope.meta.calendar.editor.timezoneEditorTitle.lookUpMsg.text,
                        timezoneEditorButton: $rootScope.meta.calendar.editor.timezoneEditorButton.lookUpMsg.text,
                        timezoneTitle: $rootScope.meta.calendar.editor.timezoneTitle.lookUpMsg.text,
                        noTimezone: $rootScope.meta.calendar.editor.noTimezone.lookUpMsg.text,
                        editorTitle: $rootScope.meta.calendar.editor.editorTitle.lookUpMsg.text
                    }
                },
                timezone: "Etc/UTC",
                currentTimeMarker: {
                    useLocalTimezone: false
                },
                dataSource: $scope.dataSource,
                resources: [{
                    field: "category",
                    title: "category",
                    dataSource: [] 
                }],
                remove: function (e) {
                    var scheduler = e.sender;
                    var cat = e.event.category;
                    var activities = e.event.goalActivities;
                    var hasActivities = (activities && activities.length > 0) ? true : false;

                    if (cat !== knownCategories.MonsterDbAppointment
                        && cat !== knownCategories.CareerPlanGoal
                        && cat !== knownCategories.CareerPlanActivity
                        && cat !== knownCategories.CareerPlanRecommendedActivity) {
                        e.preventDefault();
                    }

                    $scope.goalId = e.event.id.split('-')[1];

                    if (cat === knownCategories.CareerPlanGoal && hasActivities && !e.event.isConfirmed) {
                        $scope.calendarMessages.confirmDeleteTitle = $rootScope.meta.calendar.monster.careerPlanGoalWithActivities.confirmDeleteTitle.lookUpMsg.text;
                        $scope.calendarMessages.confirmDeleteBody = $rootScope.meta.calendar.monster.careerPlanGoalWithActivities.confirmDeleteBody.lookUpMsg.text;

                        var parsedActivities = [];
                        if (activities) {
                            for (var i = 0; i < activities.length; i++) {
                                parsedActivities.push(activities[i].name);
                            }
                        }
                        $scope.calendarMessages.activities = parsedActivities;

                        $('.k-popup-edit-form .k-scheduler-cancel').click();
                        $scope.confirmDelete(function () {
                            e.event.isConfirmed = true;
                            scheduler.removeEvent(e.event);
                        });
                        e.preventDefault();
                    }
                },
                dataBound: function (e) {
                    var scheduler = e.sender;
                    $(".k-event").each(function () {
                        var uid = $(this).data("uid");
                        if (uid) {
                            var event = scheduler.occurrenceByUid(uid);
                            if (event) {
                                var overrideDelete = null;
                                switch(event.category)
                                {
                                    case knownCategories.Holiday:
                                    case knownCategories.EtoRegisteredEvents:
                                        $(this).find(".k-event-delete,.k-resize-handle").hide();
                                        break;
                                    case knownCategories.CareerPlanActivity:
                                    case knownCategories.CareerPlanRecommendedActivity:
                                        $(this).find(".k-resize-handle").hide();
                                        overrideDelete = {
                                            title: $rootScope.meta.calendar.monster.careerPlanActivity.confirmDeleteTitle.lookUpMsg.text,
                                            body: $rootScope.meta.calendar.monster.careerPlanActivity.confirmDeleteBody.lookUpMsg.text
                                        };
                                        break;
                                    case knownCategories.CareerPlanGoal:
                                        $(this).find(".k-resize-handle").hide();
                                        overrideDelete = {
                                            title: $rootScope.meta.calendar.monster.careerPlanGoal.confirmDeleteTitle.lookUpMsg.text,
                                            body: $rootScope.meta.calendar.monster.careerPlanGoal.confirmDeleteBody.lookUpMsg.text
                                        };
                                        break;
                                    case knownCategories.MonsterDbAppointment:
                                        if ((!event.recurrenceRule || event.recurrenceRule === "") && (!event.recurrenceId || event.recurrenceId === ""))
                                        {
                                            overrideDelete = {
                                                title: $rootScope.meta.calendar.monster.monsterDbAppointment.confirmDeleteTitle.lookUpMsg.text,
                                                body: $rootScope.meta.calendar.monster.monsterDbAppointment.confirmDeleteBody.lookUpMsg.text
                                            };
                                        }
                                        break;
                                }

                                if (overrideDelete)
                                {
                                    $(this).find(".k-event-delete").click(function (event) {
                                        $scope.calendarMessages.confirmDeleteTitle = overrideDelete.title;
                                        $scope.calendarMessages.confirmDeleteBody = overrideDelete.body;
                                        $scope.confirmDelete(function () {
                                            scheduler.removeEvent(uid);
                                        });
                                        e.preventDefault();
                                        //e.stopPropagation();
                                    });
                                }
                            }
                        }
                    });
                },
                add: function (e) {
                    if (!authentication.isAuthenticated())
                    {
                        e.preventDefault();
                        return;
                    }
                    e.event.category = knownCategories.MonsterDbAppointment;
                },
                edit: function (e) {
                    var cat = e.event.category;

                    if (cat === knownCategories.Holiday) {
                        e.preventDefault();
                        return;
                    }

                    var scopeID = e.event.scopeID;
                    var parentScopeID = e.event.parentScopeID;
                    var scheduler = e.sender;

                    e.container.find("[data-container-for=category], [for=category]").hide();

                    if (cat === knownCategories.CareerPlanGoal || cat === knownCategories.CareerPlanActivity || cat === knownCategories.CareerPlanRecommendedActivity) {
                        e.container.find("input, textarea").attr('disabled', 'disabled').css('background-color', '#EEE');
                        e.container.find("input[name=start][data-role=datepicker]").data().kendoDatePicker.readonly();
                        e.container.find("input[name=start][data-role=datetimepicker]").data().kendoDateTimePicker.readonly();
                        e.container.find("input[name=end][data-role=datepicker]").data().kendoDatePicker.readonly();
                        e.container.find("input[name=end][data-role=datetimepicker]").data().kendoDateTimePicker.readonly();
                        e.container.find("[name=recurrenceRule][data-role=recurrenceeditor], [for=recurrenceRule]").parent().hide();
                        e.container.find("[role=listbox], [for=category]").parent().hide();

                        e.container.find(".k-scheduler-update")
                            .text($rootScope.meta.calendar.monster.edit.lookUpMsg.text)
                            .click(function (e) {
                                if (cat === knownCategories.CareerPlanGoal)
                                {
                                    window.location = ('/careerPlan#/goal/{0}'.format(scopeID));
                                }
                                else
                                {
                                    window.location = ('/careerPlan#/goal/{0}'.format(parentScopeID));
                                }
                                e.preventDefault();
                            });
                    }
                }
            };

            init();
        }
    };

})();


(function () {
    'use strict';
    angular.module('globalApp').directive('ocsChart', ['$parse', '$rootScope', '$log', 'templateUrlService', directiveFunction]);

    function directiveFunction($parse, $rootScope, $log, templateUrlService) {
            return {
                restrict: 'E',
                templateUrl: templateUrlService.get('ocs-Chart.html'),
                link: function (scope, element, attrs) {
                    var id = attrs['id'];
                    var settings = $parse(attrs['settings'])(scope);

                    var baseSettings = { holderId: id, width: settings.width, height: settings.height };
                    var typeSettings = settings.typeSettings;

                    scope.set = new nfzChart(baseSettings)[settings.type](typeSettings, settings.mockData);
                }
            };
        };

})();

(function () {
    'use strict';
    angular.module('globalApp').directive("ocsCheckBox", ['$rootScope', 'templateUrlService', directiveFunction]);

    function directiveFunction($rootScope, templateUrlService) {
        return {
            restrict: "E",
            scope: {
                meta: "=",
                model: "="
            },
            templateUrl: templateUrlService.get('ocs-CheckBox.html'),
            replace: true,
            link: function (scope, element, attrs) {
                if ($rootScope.IdCounter === undefined) { $rootScope.IdCounter = 0; }
                scope.elementID = "elem_" + $rootScope.IdCounter++;

                // check off the defaults based on the initial model
                scope.$watch("model", function (newValue, oldValue) {

                    if (newValue) {
                        if (scope.model.length > 0) {
                            scope.temp = {};

                            for (var y = 0; y < scope.meta.items.length; y++) {
                                for (var x = 0; x < scope.model.length; x++) {
                                    if (scope.model[x] == scope.meta.items[y].value) {
                                        scope.temp[y] = scope.model[x];
                                        break;
                                    }
                                    else {
                                        scope.temp[y] = false;
                                    }
                                }
                            }
                            scope.modelTemp = scope.temp;
                        } 
                    } else {
                       if (scope.meta && scope.meta.required) {
                            scope.singleItemForm.$setValidity('required', false);
                        }
                    }
                });

                    
                // update the model when the check boxes when user clicks a checkbox
                scope.$watch("modelTemp", function (newValue, oldValue) {
                    var t = new Array();

                    for (var w in newValue) {
                        if (newValue[w]) {
                            t.push(newValue[w]);
                        }
                    }
                    
                    if (t.length >= 0) {
                        if (scope.meta && scope.meta.isSingleSelect) { //support for single checked checkbox
                            scope.model = t[0];
                        } else {
                            scope.model = t;
                        }                        
                    }

                    if ((!scope.model || scope.model.length === 0) && scope.meta && scope.meta.required) {
                            scope.singleItemForm.$setValidity('required', false);
                     }
                    else {
                        scope.singleItemForm.$setValidity('required', true);
                    }

                }, true);
            }
        };
    };

})();


(function () {
    'use strict';
    angular.module('globalApp').directive("ocsDate", ['$rootScope', 'templateUrlService', directiveFunction]);

    function directiveFunction($rootScope, templateUrlService) {
        return {
            restrict: "E",
            scope: {
                meta: "=",
                model: "=",
                match: "@"
            },
            templateUrl: templateUrlService.get('ocs-Date.html'),
            replace: true,
            controller: ['$scope', function ($scope) {
          
                // this syncronizes the dateOptions with the meta, if the meta changes
                $scope.$watchCollection('meta', function (newVal, oldVal) {
                    var max = newVal.maxDate;
                    if (max) {
                        if (max != 'today') {
                            $scope.dateOptions.maxDate = new Date(max);
                        }
                    }
                    var min = newVal.minDate;
                    if (min) {
                        if (min != 'today') {
                            $scope.dateOptions.minDate = new Date(min);
                        }
                    }
                });

                var dateFormat = (function(){
                    var coll = $scope.meta.minMode;
                    if (coll) {
                        var types = {
                            'month': function(){ return 'MM/yyyy'},
                            'year': function(){ return 'yyyy'},
                            'default': function (){ return 'MM/dd/yyyy'}
                        }
                        return (types[coll] || types['default'])();
                    } else {
                        return 'MM/dd/yyyy';
                    }
                })();

                $scope.format = dateFormat;
                $scope.dateOptions = {
                    datepickerMode: $scope.meta.dateMode || 'day',
                    startingDay: 1,
                    showWeeks: false,
                    minMode:  $scope.meta.minMode || 'day' 
                };


                if ($scope.model !== undefined && $scope.model !== '' && $scope.model !== null) {
                    $scope.model = new Date($scope.model);
                } else {
                    $scope.model = null;
                }


                // max date
                if ($scope.meta.maxDate === 'today') {
                    angular.extend($scope.dateOptions, {
                        maxDate: new Date()
                    });
                }
                if ($scope.meta.maxDate !== 'today') {
                    angular.extend($scope.dateOptions, {
                        maxDate: new Date($scope.meta.maxDate),
                        minDate: new Date($scope.meta.minDate)
                    });
                }


                // min date
                if ($scope.meta.minDate === 'today') {
                    angular.extend($scope.dateOptions, {
                        minDate: new Date()
                    });
                }



            }],
            compile: function (element, attrs) {
                return {
                    pre: function preLink(scope, element, attrs) {
                        // look up mask name and resolve, if not found then pass value as is
                        if ($rootScope.productVariables.standardMask) {
                            var temp = $rootScope.productVariables.standardMask[scope.meta.mask];
                            scope.mask = (temp === undefined) ? scope.meta.mask : temp;
                        }

                        //allows to resize the form
                        scope.formSize = attrs.formSize;
                    },
                    post: function (scope, elem, attrs, ctrl) {
                        // this incriments the global counter and creates a new uneque ID
                        if ($rootScope.IdCounter === undefined) { $rootScope.IdCounter = 0; }
                        scope.elementID = "elem_" + $rootScope.IdCounter++;


                        //  set error state if the model is null (backspace till empty)
                        scope.$watch('model', function (newVal, oldVal) {
                            //console.log(newVal);
                            if (newVal == null){
                                scope.singleItemForm.$valid = false;
                            }
                        });
                    }
                };
            }
        };
    };
})();




(function () {
    'use strict';
    angular.module('globalApp').directive("ocsError", ['$rootScope', 'templateUrlService', directiveFunction]);

    function directiveFunction($rootScope, templateUrlService) {
        return {
            restrict: "E",
            scope: {
                errorList: "=",
            },
            templateUrl: templateUrlService.get('ocs-Error.html'),
            replace: true,
            link: function (scope, element, attrs) {
                scope.popError = function (key) {
                    scope.errorList.splice(key, 1);
                }
            }
        };
    };



})();


(function ($) {
    'use strict';
    angular.module('globalApp').directive('ocsFontSize', ['cacheService', '$rootScope', 'templateUrlService', directiveFunction]);

    function directiveFunction(cacheService, $rootScope, templateUrlService) {
        return {
            restrict: 'E',
            templateUrl: templateUrlService.get('ocs-FontSize.html'),
            replace: true,
            link: link
        }
        
        function link(scope, elem, attrs) {
            var body = $('body');
            var sizes = [body.css('font-size'), '17px', '20px'];
            var aTags = $(elem).find('a');
            var cacheType = $rootScope.productVariables.caching.cacheTypesEnum.sharedCache;
            var fontSize = cacheService.provider(cacheType).get('fontSize');
            var sizeIndex = (fontSize) ? sizes.indexOf(fontSize) : undefined;

            if (sizes.length === aTags.length && fontSize) {
                activateTag(aTags.eq(sizeIndex), sizes[sizeIndex]);
            } else {
                activateTag(aTags.eq(0), sizes[0]);
            }
            
            for (var i = 0, length = aTags.length; i < length; i += 1) {
                bindTo(aTags.eq(i), i);
            }

            function bindTo(elem, index) {
                elem.on('click', function () {
                    var aTag = $(this);
                    if (!aTag.hasClass('active')) {
                        cacheService.provider(cacheType).addOrUpdate('fontSize', sizes[index]);
                        activateTag(aTag, sizes[index]);
                    }
                });
            }

            function activateTag(target, fontSize) {
                aTags.removeClass('active');
                target.addClass('active');
                body.css('font-size', fontSize);
            }
        }
    }
})(jQuery);
(function (angular) {
    'use strict';
    angular.module('globalApp').directive('ocsHelp', ['$rootScope', 'templateUrlService', directiveFunction]);
   
    function directiveFunction ($rootScope, templateUrlService) {
        return {
            restrict: 'E',
            scope: {
                meta: '='
            },
            templateUrl: templateUrlService.get('ocs-Help.html'),
        }
    }
})(angular);
(function () {
    'use strict';
    angular.module('globalApp').directive('ocsHtmlFrame', ['$parse', '$rootScope', '$log', 'utilityService', directiveFunction]);

    function directiveFunction($parse, $rootScope, $log, utilityService) {
            return {
                restrict: 'E',
                replace: true,
                scope: {
                    content: '=content',
                    type: '=type',
                    src: '=src'
                },
                link: function (scope, element, attrs) {
                    scope.$watchGroup(['content', 'src'], function () {
                        console.log(scope.src);
                        var iframe = document.createElement('iframe');
                        if (scope.src && scope.src.length > 0) {
                            iframe.src = scope.src;
                            iframe.onload = function () {
                                this.style.height = this.contentWindow.document.body.scrollHeight + 'px';

                                utilityService.replaceCoreEmailLink(this);
                            }
                        } else if (scope.content) {
                            iframe.src = 'data:text/html;charset=utf-8,' + encodeURI(scope.content);
                        }
                        iframe.width = "100%";
                        iframe.height = "800px";
                        iframe.scrolling = "no";
                        iframe.frameBorder = 0;
                        element.empty();
                        element.append(iframe);
                    });
                }
            };
        };
})();
(function () {
    'use strict';
    angular.module('globalApp').directive("ocsInput", ['$rootScope', 'templateUrlService', 'autoCompleteFactory', 'UserAudit', directiveFunction]);

    function directiveFunction($rootScope, templateUrlService, autoCompleteFactory, UserAudit) {
        var emailRX = /.+@.+\..{2,3}$/i;
        return {
            restrict: "E",
            scope: {
                meta: "=",
                model: "=",
                addOn: "=",
                match: "@",
                valideemail: '='
            },
            require: '?model',
            templateUrl: templateUrlService.get('ocs-Input.html'),
            //replace: true,
            controller: ['$scope', function ($scope) {
                if ($scope.valideemail !== undefined) {
                    $scope.$watch(function () { return $scope.singleItemForm; }, function (n, o) {
                        if (n !== undefined) {
                            $scope.checkEmailExists = function () {
                                n.$setValidity('emailexists', true);
                                n.$setDirty();

                                if ($scope.model !== undefined) {
                                    UserAudit.getUserByEmail({ emailAddress: $scope.model }).$promise.then(function (data) {
                                        if (data.userId > 0) {
                                            n.$setValidity('emailexists', false);
                                            n.$setDirty();
                                        } else {
                                            n.$setValidity('emailexists', true);
                                            n.$setDirty();
                                        }
                                    }, function (err) {
                                        console.log(err);
                                    });
                                }
                            }
                        }
                    });
                }
            }],
            link: function (scope, element, attrs, ctrl) {
                //if (!ctrl) { return; }
                //console.log(ctrl);
                // set the form invalid if there are custom errors displayed
                //scope.$watch("meta.customValidatorNames", function (newValue, oldValue) {
                //    if (oldValue) {
                //        if (newValue.length > 0) {
                            //console.log(ctrl);
                            //ctrl.$setValidity("singleItemForm.$error.skillDupe", true);
                            //console.log('the form is in an error state');
                            //  wrong!! element.singleItemForm.$invalid = true;
                            //  possable solution,  look to contect us page for example
                            //    ctrl.$setValidity('regexValidate', regex.test(value));
                //        }
                //    }
                //});
                

                scope.getTypeAhead = function () {
                    //var browser = BrowserDetect().init().browser;
                    //console.log(browser);
                    if (scope.model.indexOf("-") > -1) {
                        scope.model = scope.model.split(/ - (.+)?/)[1];
                        scope.meta.autoCompleteData = [];
                    } else {
                        autoCompleteFactory[scope.meta.autoComplete]({ query: scope.model }).$promise.then(function (data) {
                            scope.meta.autoCompleteData = data.items;
                        });
                    }
                };

                // this incriments the global counter and creates a new uneque ID
                if ($rootScope.IdCounter === undefined) { $rootScope.IdCounter = 0; }
                scope.elementID = "elem_" + $rootScope.IdCounter++;

                //allows to resize the form
                scope.formSize = attrs.formSize;

                //if (scope.meta && scope.meta.type === 'email') {
                //    scope.meta.type = 'text';
                //    // This regex doesn't allow for double 
                //    scope.meta.pattern = emailRX;
                //}
                // look up mask name and resolve, if not found then pass value as is
                //temp = $rootScope.productVariables.standardMask[scope.meta.mask];
                //if (temp == undefined) { scope.mask = scope.meta.mask; } else { scope.mask = temp; }

                scope.filter = function (event) {
                    //console.log(event.keyCode);

                    if ((event.keyCode >= 49) && (event.keyCode <= 57)) {
                        c = String.fromCharCode(event.keyCode);
                        if (scope.model == undefined) { scope.model = c; } else { scope.model = scope.model + c; }
                        //event.preventDefault();
                    }
                }

                

                if (scope.meta) {
                    //replace the pattern if its in the look up table
                    if (scope.meta.pattern) {
                        switch (scope.meta.pattern) {
                            case "email":
                                scope.meta.pattern = emailRX;
                                break;
                            case "ssn":
                                //scope.meta.pattern = /^(9[0-9]{8})|(000[0-9]{6})|(666[0-9]{6})|([0-9]{3}00[0-9]{4})|([0-9]{5}0000)$/;   // from MGS 1000
                                  scope.meta.pattern = /^(?!000)(?!666)(?!9)\d{3}[- ]?(?!00)\d{2}[- ]?(?!0000)\d{4}$/; // http://jsfiddle.net/scottux/7cMV3/ 
                                break;
                        }
                    }


                    // allows trailing space char on passwords
                    if (scope.meta.type === "password") { scope.trim = false; }


                }

                if (scope.meta && scope.meta.mask) {
                    var maskEvents = (scope.meta.mask && scope.meta.mask.bindMaskEvents) ? scope.meta.mask.bindMaskEvents : 'undefined';

                    if (typeof maskEvents !== 'undefined') {
                        for (var eventName in maskEvents) {
                            element.bind(eventName, function ($event) { });
                        }
                    }
                }



            }
        };

    };

})();


(function () {
    'use strict';
    angular.module('globalApp').directive('ocsLogin', ['$rootScope', '$httpParamSerializer', '$location', 'authentication', 'registry', '$window', 'templateUrlService', directiveFunction]);

    function directiveFunction($rootScope, $httpParamSerializer, $location, authentication, registry, $window, templateUrlService) {
        return {
            restrict: "E",
            scope: {
                meta: "=",
            },
            templateUrl: templateUrlService.get('ocs-Login.html'),
            replace: true,
            link: function (scope, $rootScope, element, attrs) {
                var preFillEmail = registry.get('global', 'logInEmail', 'sessionStorage');
                if (preFillEmail !== undefined) {
                    scope.userName = preFillEmail;
                    registry.remove('global', 'logInEmail', 'sessionStorage');
                } else {
                    scope.userName = "";
                }
              
                scope.password = "";
                
                scope.createAccount = function () {
                    var location = '/account#/?' + $httpParamSerializer({ callout: { type: 'redirect', data: $location.absUrl() } });
                    if ($rootScope.login && $rootScope.login.callout) {
                        location = '/account#/?' + $httpParamSerializer({ callout: $rootScope.login.callout });
                    }
                    $window.location = location;
                };

                // for login authentication 
                scope.authenticateLogin = function () {
                    authentication.login(scope.userName, scope.password).then(
                    function (result) {
                        //console.log(result.success);
                        if (result.success) {
                            //$window.location.href = result.url;
                        }
                        else {
                            scope.error = true;
                            scope.isBusy = false;
                        }
                    });
                };
            }
        };

    };

})();



//usage
//ocs-match="modelNameThatWeWantToMatch"  <input type="text/password ect..."/> 
//provide error handeling on the front end ex: ng-show="formName.$error.match"
(function () {
    'use strict';
    var directiveId = 'ocsMatch';
    angular.module('globalApp').directive(directiveId, ['$parse', directiveFunction]);

    function directiveFunction($parse) {
	    return {
	        require: '?ngModel',
	        restrict: 'A',
	        link: link
	    };

	    //ctrl is provided with an (? = optional) ngModel
	    function link(scope, elem, attrs, ctrl) {
	        // if ngModel is not defined, we don't need to do anything
	        if (!ctrl) { return; }
	        if (!attrs[directiveId]) { return; }
	        
	        //$parse converts angular expression into a function.
	        var firstInput = $parse(attrs[directiveId]);

	        // match is sending object instead of model e.g. match="{ model: model.startDate, operator: 'dateGreaterThan'}"
	        var operators = {
	            "default": function (a, b) { return a == b },
	            "dateMatch": function (a, b) { return Date.parse(a) == Date.parse(b) },
	            "dateGreaterThan": function (a, b) { return Date.parse(a) >= Date.parse(b) },
                "dateLesserThan": function (a, b) { return Date.parse(a) <= Date.parse(b) }
	        }

	        var validator = function (value) {
	            //retrieves the value of the first input control (scope) default
	            //(value = 1st field) comparing to (temp = 2nd field)
                var selector = (scope.$parent.match === undefined) ? firstInput(scope.$parent) : firstInput(scope);
	            var isValidObject = (typeof selector === "object" && selector.operator in operators);
	            var temp = isValidObject ? selector.model : selector;

                // prevent displaying validation if one field does not have any value (for date comparison)
	            var isNull = isValidObject && ((typeof temp === 'undefined' || temp === null) || value === null);
	            
	            var v = isValidObject ? operators[selector.operator](value, temp) : operators['default'](value, temp);

	            //sets the value of the match form state control that contributes
	            //to the validity of the input control, also referenced by
	            //the ng-show attribute (to show or hide the hint)
	            ctrl.$setValidity('match', isNull ? true : v);

	            return value;
	        };

	        ctrl.$parsers.unshift(validator);
	        ctrl.$formatters.push(validator);

	        if (scope.$parent.match === undefined) {
	            scope.$parent.$watch(attrs[directiveId], function () {
	                validator(ctrl.$viewValue);
	            });
	        } else {
	            scope.$watch(attrs[directiveId], function () {
	                validator(ctrl.$viewValue);
	            });
	        }
	    }
	};
})();

(function() {
    'use strict';
    angular.module('globalApp').directive('maxLength', directiveFunction);

    function directiveFunction() {
        return {
            restrict: 'A',
            require: 'ngModel',                        
            link: function($scope, element, attrs, ngModel) {
                $scope.$watch(attrs.ngModel, function(value) {
                    var isValid = (((value) ? value.length : 0) <= attrs.maxLength);
                    ngModel.$setValidity('maxLength', isValid);
                });
            }
        }
    }
})();
(function () {
    'use strict';
    angular.module('globalApp').directive('modal', ['$uibModal', directiveFunction]);

    function directiveFunction($uibModal) {
        return {
            restrict: 'E',
            replace: true,
            scope: {
                shown: '=',
                okModal: '&',
                cancelModal: '&'

            },
            link: function (scope, element, attrs, ctrl) {

                //if (scope.$parent) {
                //    scope.$parent.modalOkButton();
                //}

                //okModal();

                scope.$watch('shown', function () {
                    scope.open(scope.okModal, scope.cancelModal);
                });

                // modal window open function
                scope.open = function (onOk, onCancel) {
                    if (scope.shown) {

                        scope.shown = false;
                        var modalInstance = $uibModal.open({
                            animation: true,
                            templateUrl: attrs.name,
                            controller: ('modalController', ['$scope', '$rootScope', '$uibModalInstance',
                                function ($scope, $rootScope, $uibModalInstance) {

                                    $scope.ok = function () {
                                        $rootScope.modalScope = $scope;
                                        onOk();
                                        $uibModalInstance.dismiss();
                                    };

                                    $scope.cancel = function () {
                                        $rootScope.modalScope = $scope;
                                        onCancel();
                                        $uibModalInstance.dismiss('cancel');
                                    };
                                }])
                        });

                        //modalInstance.result.then(function () {
                        //    onSuccess();
                        //    scope.okModal();
                        //});
                    }
                };
            }
        }

    };

})();

(function () {
    'use strict';
    var directiveId = 'ocsMsg';
    angular.module('globalApp').directive(directiveId, ['$parse', '$rootScope', '$log', directiveFunction]);
    
    function directiveFunction($parse, $rootScope, $log) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                var value = String($parse(attrs[directiveId])(scope));
                //to get list of IDS
                var msgArr = [];
                angular.forEach(value.split(","), function (value) {
                    msgArr.push(Number(value));
                });
            }
        };
    };

})();

(function () {
    'use strict';
    angular.module('globalApp').directive('ocsNavbar', ['$rootScope', '$timeout', 'screenSize', 'templateUrlService', directiveFunction]);

    function directiveFunction($rootScope, $timeout, screenSize, templateUrlService) {
        return {
            restrict: 'E',
            scope: {
                meta: "=",
                settings: "="
            },
            templateUrl: templateUrlService.get('ocs-NavBar.html'),
            link: function (scope, elem, attrs) {
                //default settings
                scope.defaults = {
                    hoverDelay: 100,
                    removeInverse: false,
                    removeCarets: false,
                    enableHeaderLink: false,
                    innerMobileButtons: true
                };

                angular.merge(scope.defaults, scope.settings);

                if (screenSize.is('xs')) {
                    scope.isCollapsed = true;
                    $rootScope.isSearchCollapsed = true;
                } else {
                    scope.isCollapsed = false;
                    $rootScope.isSearchCollapsed = false;
                }

                //screenSize.when('xs', function () {
                //    scope.isCollapsed = true;
                //    $rootScope.isSearchCollapsed = true;
                //});

                var timer;
                scope.open = function (item) {
                    if (item.status.isopen === false || item.status.isopen === undefined) {
                        timer = $timeout(function () {
                           item.status.isopen = true;
                        }, scope.defaults.hoverDelay);
                    }
                };

                scope.close = function (item) {
                    $timeout.cancel(timer);
                    item.status.isopen = false;
                }

                scope.goToLink = function (obj) {
                    if (scope.defaults.enableHeaderLink) {
                        try {
                            var url = obj.item[0].url;
                            window.location = url;
                        } catch (err) {
                            console.log(err);
                        }
                    }
                }
            }
        };
    }

})();



(function () {
    'use strict';
    angular.module('globalApp').directive("ocsOnlyNumbers", ['$parse', directiveFunction]);

    function directiveFunction($parse) {
        return {
            require: '?ngModel',
            link: function (scope, element, attrs, ngModelCtrl) {

                if ($parse(attrs.ocsOnlyNumbers)(scope) === true) {
                    if (!ngModelCtrl) {
                        return;
                    }

                    ngModelCtrl.$parsers.push(function (val) {
                        if (angular.isUndefined(val)) {
                            var val = '';
                        }

                        var clean = val.replace(/[^0-9\.]/g, '');
                        var negativeCheck = clean.split('-');
                        var decimalCheck = clean.split('.');
                        if (!angular.isUndefined(negativeCheck[1])) {
                            negativeCheck[1] = negativeCheck[1].slice(0, negativeCheck[1].length);
                            clean = negativeCheck[0] + '-' + negativeCheck[1];
                            if (negativeCheck[0].length > 0) {
                                clean = negativeCheck[0];
                            }

                        }

                        if (!angular.isUndefined(decimalCheck[1])) {
                            decimalCheck[1] = decimalCheck[1].slice(0, 2);
                            clean = decimalCheck[0] + '.' + decimalCheck[1];
                        }

                        if (val !== clean) {
                            ngModelCtrl.$setViewValue(clean);
                            ngModelCtrl.$render();
                        }
                        return clean;
                    });

                    element.bind('keypress', function (event) {
                        if (event.keyCode === 32) {
                            event.preventDefault();
                        }
                    });
                }
            }
        };
    }
})();
(function () {
    'use strict';
    angular.module('globalApp').directive('ocsPager', ['$parse', '$rootScope', '$log', '$anchorScroll', 'templateUrlService', directiveFunction]);

    function directiveFunction($parse, $rootScope, $log, $anchorScroll, templateUrlService) {
        return {
            restrict: 'E',
            scope: {
                currentPage: '=currentpage',
                datasetSize: '=datasetsize',
                pageSize: '=pagesize',
                callback: '=?callback',
                pageNumberLimit: '=?pageNumberLimit'
            },

            templateUrl: templateUrlService.get('ocs-Pager.html'),

            link: function (scope, element, attrs) {

                scope.numberOfPages = Math.ceil(scope.datasetSize / scope.pageSize);
                scope.showFirstLast = eval(attrs['showfirstlast']);
                scope.showSeparators = attrs['showseparators'];
                scope.visiblePages = attrs['visiblepages'];
                scope.showLowerSeparator = false;
                scope.showUpperSeparator = false;

                scope.$watch("datasetSize", function (newValue, oldValue) {
                    scope.numberOfPages = Math.ceil(scope.datasetSize / scope.pageSize);

                    if (Number.isInteger(scope.pageNumberLimit) && scope.numberOfPages > scope.pageNumberLimit) {
                        scope.numberOfPages = scope.pageNumberLimit;
                    }
                });

                scope.setPage = function (p) {
                    if (p >= 0 && p < scope.numberOfPages) {
                        scope.currentPage = p;
                        if (typeof scope.callback == 'function') {
                            scope.callback(p);
                        }
                        $anchorScroll();
                    }
                }
                scope.range = function (currentPage) {
                    var pages = [];
                    var pageLimit = (scope.numberOfPages < scope.visiblePages) ? scope.numberOfPages : scope.visiblePages;
                    var half = Math.floor(pageLimit / 2);
                    var start = currentPage - half + 1 - pageLimit % 2;
                    var end = currentPage + half;

                    // handle boundary case
                    if (start <= 0) {
                        start = 1;
                        end = pageLimit;
                    }
                    if (end > scope.numberOfPages) {
                        start = scope.numberOfPages - pageLimit + 1;
                        end = scope.numberOfPages;
                    }

                    var itPage = start;
                    while (itPage <= end) {
                        pages.push(itPage);
                        itPage++;
                    }

                    scope.showLowerSeparator = (start > 1) ? true : false;
                    scope.showUpperSeparator = (end < scope.numberOfPages) ? true : false;;

                    return pages;
                }
            }
        };
    };

})();
(function () {
    angular.module('globalApp').directive("passwordAssist", ['$rootScope', 'templateUrlService', directiveFunction]);

    function directiveFunction($rootScope, templateUrlService) {
        return {
            restrict: "E",
            scope: {
                options: "=",
                model: "=",
                meta: "=",
                passwordconfirm: "=",
            },
            templateUrl: templateUrlService.get('ocs-PasswordAssist.html'),
            replace: true,
            link: function (scope, element, attrs) {
                //Setting up defaults
                var hasOptions = (scope.options !== undefined);
                scope.defaults = {
                    minLength: hasOptions ? scope.options.minLength || 8 : 8,
                    maxLength: hasOptions ? scope.options.maxLength || 20 : 20,
                    noSpaces: hasOptions ? scope.options.noSpaces || true : true,
                    digits: hasOptions ? scope.options.digits || true : true,
                    lowerUpperCases: hasOptions ? scope.options.lowerUpperCases || true : true,
                    nonWordCharacter: hasOptions ? scope.options.nonWordCharacter || true : true,
                    messageCharacters: scope.meta.RequirementMessages[0].text,
                    messageMinimumOf: scope.meta.RequirementMessages[1].text,
                    messageLengthShouldNotExceed: scope.meta.RequirementMessages[2].text,
                    messageContainsUppercaseAndLowercaseLetters: scope.meta.RequirementMessages[3].text,
                    messageContainsNumbers: scope.meta.RequirementMessages[4].text,
                    messageContainsSpecialCharacters: scope.meta.RequirementMessages[5].text,
                    messageDoesntContainSpaces: scope.meta.RequirementMessages[6].text,
                    messagePasswordsMatch: scope.meta.RequirementMessages[7].text
                };

                //Watching for model changes
                scope.$watch('model', function () {
                    if (scope.model !== undefined) {
                        scope.min = (scope.model.length >= scope.defaults.minLength) ? true : false;
                        scope.max = (scope.model.length <= scope.defaults.maxLength) ? true : false;
                        scope.spaces = (scope.defaults.noSpaces === true) ? !matchSpaces(scope.model) : matchSpaces(scope.model);
                        scope.upperLower = (scope.defaults.lowerUpperCases === true) ? !matchUpperLower(scope.model) : matchUpperLower(scope.model);
                        scope.digits = (scope.defaults.digits === true) ? !matchDigit(scope.model) : matchDigit(scope.model);
                        scope.characters = (scope.defaults.nonWordCharacter === true) ? !matchNonWordCharacter(scope.model) : matchNonWordCharacter(scope.model);
                        scope.isMatched = scope.passwordconfirm == scope.model;
                    }
                });

                scope.$watch('passwordconfirm', function () {
                    if (scope.passwordconfirm !== undefined) {
                        scope.isMatched = scope.passwordconfirm === scope.model;
                    }
                });
            }
        };
        // use positive look ahead to see if at least one space exists
        // NOTE: if used on the password type inputs add ng-trim="false" to detect all white spaces.
        function matchSpaces(e) {
            return (e.match(/^\S+$/) === null) ? true : false;
        }
        // use positive look ahead to see if at least one lower & upper case letters exists
        function matchUpperLower(e) {
            return (e.match(/^(?=.*[a-z])(?=.*[A-Z]).+$/) === null) ? true : false;
        }
        // use positive look ahead to see if at least one digit exists
        function matchDigit(e) {
            return (e.match(/^(?=.*\d).+$/) === null) ? true : false;
        }
        // use positive look ahead to see if at least one underscore or non-word character exists
        function matchNonWordCharacter(e) {
            return (e.match(/^(?=.*[_\W]).+$/) === null) ? true : false;
        }

    };

})();
(function () {
    'use strict';
    globalApp.directive("ocsRadio", ['$rootScope', 'templateUrlService', directiveFunction]);

    function directiveFunction($rootScope, templateUrlService) {
        return {
            restrict: "E",
            scope: {
                meta: "=",
                model: "="
            },
            templateUrl: templateUrlService.get('ocs-Radio.html'),
            replace: true,
            link: function (scope) {
                if ($rootScope.IdCounter === undefined) { $rootScope.IdCounter = 0; }
                scope.elementID = "elem_" + $rootScope.IdCounter++;
                scope.elementLegendID = "elem_" + $rootScope.IdCounter++;

                //if (scope.meta.defaultSelected) {
                //    scope.model = scope.meta.defaultSelected;
                //}

            }
        };

    };

})();

(function () {
    "use strict";
    globalApp.directive("ocsRecommendedJobs", ['$rootScope', 'jobSearchFactory', 'authentication', 'utilityService', 'templateUrlService', directiveFunction]);

    function directiveFunction($rootScope, jobSearchFactory, authentication, utilityService, templateUrlService) {
        var scope = {
            meta: "="
        };
        return {
            restrict: "E",
            scope: scope,
            templateUrl: templateUrlService.get('ocs-RecommendedJobs.html'),
            controller: controller
        };

        function controller()
        {
            function init() {
                reset();
                scope.doneLoading = false;
                jobSearchFactory.recommendedJobs(function (data) {
                    angular.forEach(data, function (value) {
                        value.url = '/jobView#/' + utilityService.tokenize(value.title) + '-id-' + value.source.toLowerCase() + '-' + value.id;
                    });
                    scope.jobs = data;
                    scope.doneLoading = true;
                });
            }
            function reset() {
                scope.jobs = [];
                scope.doneLoading = true;
            }
            authentication.setup(init, reset, false);
        }
    };
})();

(function () {
    angular.module('globalApp').directive('ocsRepeaterFinished', ['$timeout', function ($timeout) {
        return {
            restrict: 'A',
            link: function (scope, element, attr) {
                if (scope.$last === true) {
                    $timeout(function () {
                        scope.$emit(attr.ocsRepeaterFinished);
                    });
                }
            }
        }
    }]);
})();
(function () {
    'use strict';
    angular.module('globalApp').directive("ocsResumeUploadedPreview", ['$rootScope', 'resumesFactory', '$http', directiveFunction]);

    function directiveFunction($rootScope, resumesFactory, $http) {
        return {
            restrict: "E",
            bindToController: {
                model: '=',
                documents: '='
            },
            controllerAs: 'ctrl',
            templateUrl: $rootScope.registry.localStore.global.context.templateUrl + 'ocs-resume-uploaded-preview.html',
            controller: function () {

                var ctrl = this;
                ctrl.loading = false;
                ctrl.pdfDocInfo = {};
                ctrl.currentPdfPage = 1;
                ctrl.pdfPreviewImgPercentWidth = 100;
                ctrl.pdfPreviewImgPercentWidthMin = 25;
                ctrl.pdfPreviewImgPercentWidthMax = 200;
                ctrl.fileTypePdf = ".pdf";
                var pdfZoomPercentStep = 25;
                var pdfPreviewCache = [];

                ctrl.getResumePdfNumOfPages = function () {
                    resumesFactory.getResumePdfNumOfPages({ resumeValue: ctrl.model.resumeValue }).$promise.then(function (data) {
                        ctrl.pdfDocInfo = data;
                    }, function (error) {
                        //console.log(error);
                    });
                }

                ctrl.getResumePdfPageAsImage = function () {
                    var url = $rootScope.productVariables.rootUrl + '/seeker/api/me/resumes/' + ctrl.model.resumeValue + '/pdfresume/' + ctrl.currentPdfPage.toString();
                    if (pdfPreviewCache[ctrl.currentPdfPage]) {
                        ctrl.pdfImage = pdfPreviewCache[ctrl.currentPdfPage];
                    } else {
                        ctrl.loading = true;
                        $http.get(url, { responseType: 'blob' }).then(function successCallback(response) {
                            var d = response.data;
                            var blob = new Blob([d], { type: 'image/png' });
                            var src = URL.createObjectURL(blob);
                            ctrl.pdfImage = src;
                            pdfPreviewCache[ctrl.currentPdfPage] = src;
                            ctrl.loading = false;
                        }, function errorCallback(response) {
                            //console.log(response);
                        });
                    }
                }

                ctrl.goToPreviousPage = function () {
                    if (ctrl.currentPdfPage > 1) {
                        ctrl.currentPdfPage--;
                        ctrl.getResumePdfPageAsImage();
                    }
                }

                ctrl.goToNextPage = function () {
                    if (ctrl.currentPdfPage < ctrl.pdfDocInfo.pageNo) {
                        ctrl.currentPdfPage++;
                        ctrl.getResumePdfPageAsImage();
                    }
                }

                ctrl.pdfZoomOut = function () {
                    if (ctrl.pdfPreviewImgPercentWidth > ctrl.pdfPreviewImgPercentWidthMin) {
                        ctrl.pdfPreviewImgPercentWidth = ctrl.pdfPreviewImgPercentWidth - pdfZoomPercentStep;
                    }
                }

                ctrl.pdfZoomIn = function () {
                    if (ctrl.pdfPreviewImgPercentWidth < ctrl.pdfPreviewImgPercentWidthMax) {
                        ctrl.pdfPreviewImgPercentWidth = ctrl.pdfPreviewImgPercentWidth + pdfZoomPercentStep;
                    }
                }

                
                if (ctrl.documents && ctrl.documents[0] && ctrl.documents[0].fileType == ctrl.fileTypePdf) {
                    ctrl.getResumePdfNumOfPages();
                    ctrl.getResumePdfPageAsImage();
                }


            }
        };
    };

})();
(function () {
    "use strict";
    angular.module('globalApp').directive("ocsRichtexteditor", ['$rootScope', 'templateUrlService', directiveFunction]);

    function directiveFunction($rootScope, templateUrlService) {
        return {
            restrict: "E",
            scope: {
                meta: "=",
                model: "="
            },
            templateUrl: function (element, attrs) { return attrs.templateUrl || templateUrlService.get('ocs-RichTextEditor.html'); },
            replace: true,
            transclude: false,
            link: function (scope, element, attrs) {
                //set the elementId generated by the underlying tinyMCE directive
                scope.elimentId = element.find('textarea').attr('id');
            }
        };
    };
})();



(function (angular) {
    "use strict";
    // reference: http://stackoverflow.com/questions/17470370/how-to-implement-a-scrollspy-in-angular-js-the-right-way
    angular.module('globalApp').directive('ocsScrollSpy', ['$window', function ($window) {
        return {
            restrict: 'A',
            controller: ['$scope', function ($scope) {
                $scope.spies = [];
                this.addSpy = function (spyObj) {
                    $scope.spies.push(spyObj);
                };
            }],
            link: function (scope, elem, attrs) {
                var spyElems;
                spyElems = [];

                scope.$watch('spies', function (spies) {
                    var spy, _i, _len, _results;
                    _results = [];

                    for (_i = 0, _len = spies.length; _i < _len; _i++) {
                        spy = spies[_i];

                        if (spyElems[spy.id] == null) {
                            _results.push(spyElems[spy.id] = elem.find('#' + spy.id));
                        }
                    }
                    return _results;
                });

                $($window).scroll(function () {
                    var highlightSpy, pos, spy, _i, _len, _ref;
                    highlightSpy = null;
                    _ref = scope.spies;

                    // cycle through `spy` elements to find which to highlight
                    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                        spy = _ref[_i];
                        spy.out();

                        // catch case where a `spy` does not have an associated `id` anchor
                        if (spyElems[spy.id].offset() === undefined) {
                            continue;
                        }

                        if ((pos = spyElems[spy.id].offset().top) - $window.scrollY <= 5) {
                            // the window has been scrolled past the top of a spy element
                            spy.pos = pos;

                            if (highlightSpy == null) {
                                highlightSpy = spy;
                            }
                            if (highlightSpy.pos < spy.pos) {
                                highlightSpy = spy;
                            }
                        }
                    }

                    // select the last `spy` if the scrollbar is at the bottom of the page
                    if ($(window).scrollTop() + $(window).height() >= $(document).height()) {
                        spy.pos = pos;
                        highlightSpy = spy;
                    }

                    return highlightSpy != null ? highlightSpy["in"]() : void 0;
                });
            }
        };
    }]);

    angular.module('globalApp').directive('spy', ['$location', '$anchorScroll', function ($location, $anchorScroll) {
        return {
            restrict: "A",
            require: "^ocsScrollSpy",
            link: function (scope, elem, attrs, affix) {
                elem.click(function () {
                    scope.$apply(function () {
                        $location.hash(attrs.spy);
                    });
                    $anchorScroll();
                });

                affix.addSpy({
                    id: attrs.spy,
                    in: function () {
                        elem.addClass('active');
                    },
                    out: function () {
                        elem.removeClass('active');
                    }
                });
            }
        };
    }]);
})(angular);
(function () {
    "use strict";
    angular.module('globalApp').directive('ocsSelect', ['$rootScope', 'templateUrlService', directiveFunction]);
    
    function directiveFunction($rootScope, templateUrlService) {
        return {
            restrict: "E",
            scope: {
                meta: "=",
                model: "=",
                changeFn: "&"
            },
            templateUrl: templateUrlService.get('ocs-Select.html'),
            replace: true,
            controller: ["$scope", function ($scope) {
                // this incriments the global counter and creates a new uneque ID
                if ($rootScope.IdCounter === undefined) { $rootScope.IdCounter = 0; }
                $scope.elementID = "elem_" + $rootScope.IdCounter++;
            }],
            link: function (scope, element, attrs) {

                // this is a manual way to add a default to the top of a select list.
                if (scope.meta && scope.meta.addDefault && scope.meta.addDefault.lookUpMsg && scope.meta.addDefault.lookUpMsg.value) {
                    if (scope.meta.items && scope.meta.items.constructor === Array && scope.meta.items[0].value !== null ) {
                        scope.meta.items.unshift({ value: null, text: scope.meta.addDefault.lookUpMsg.value });
                    }
                }

                // this fixes the angular bug that leaves a blank line on the top of a select list.
                scope.$watch("model", function (newVal, oldVal) {
                    if (!newVal && newVal !== oldVal) {
                        scope.model = scope.meta.items[0].value;
                    }
                });




                //Deep watch here so that the message change to static lists hits this
                scope.$watch("meta.items", function () {
                    if (scope.meta && scope.meta.items) {
                        // <- there are items
                        if (scope.meta.items[0]) {
                            // if there is a model value just set it
                            if (scope.model) {

                                //this will make an option on the list a "default", meeniong its value is null, and will not be valid think (--select--)
                                if (scope.meta.voidDefault) {
                                    for (var x in scope.meta.items) {
                                        if (scope.meta.items[x].value == scope.meta.voidDefault) {
                                            scope.meta.items[x].value = ""
                                        };
                                    }
                                }
                            }
                            else {
                                var modelValue = '';
                                // is a data source list
                                if (scope.meta.items[0].text.lookUpMsg == undefined) {
                                    modelValue = scope.meta.items[0].value;
                                    if (scope.meta.voidDefault) {
                                        for (x in scope.meta.items) {
                                            if (scope.meta.items[x].value == scope.meta.voidDefault) {
                                                scope.meta.items[x].value = ""
                                            };
                                        }
                                        scope.singleItemForm.$setPristine();
                                    }
                                    else {
                                        modelValue = scope.meta.items[0].value;
                                    }
                                }
                                // its a manual list
                                else {
                                    modelValue = scope.meta.items[0].value;
                                    if (scope.meta.voidDefault) {
                                        for (x in scope.meta.items) {
                                            if (scope.meta.items[x].value == scope.meta.voidDefault) {
                                                scope.meta.items[x].value = ""
                                            };
                                        }
                                        scope.singleItemForm.$setPristine();
                                    }
                                    else {
                                        modelValue = scope.meta.items[0].value;
                                    }
                                }

                                //set the scope model
                                scope.model = (scope.meta.defaultSelected) ? scope.meta.defaultSelected : modelValue;
                            }
                        }
                    }
                }, true);
            }
        };

    };

})();





(function ($) {
    'use strict';
    angular.module('globalApp').directive('ocsSpinner', ['$parse', '$timeout', directiveFunction]);

    function directiveFunction($parse, $timeout) {
        return {
            scope: {
                isLoaded: "="
            },
            restrict: 'A',
            link: function (scope, element, attrs) {
                element.css({ 'position': 'relative', 'min-height': '160px' });
                var spinner = $("<div class='ajax-spinner' style='width: 80px; height: 80px;'><i class='fa fa-spinner fa-spin fa-3x'></i></div>");
                var overlay = $("<div class='spinner-overlay'></div>");
                var options = $parse(attrs.options)(scope);
                var timer;
                var templateSize = {
                    width: spinner.width(),
                    height: spinner.height()
                };

                var dOptions = {
                    top: (options && options.top ? options.top : '50%'),
                    isOverlay: (options && !options.isOverlay && options.isOverlay !== undefined) ? options.isOverlay : true,
                };

                var initLoad = false;

                if (!initLoad) {
                    var windowHeight = $(window).height(),
                        windowWidth = element.outerWidth();
                    var topCalc = 'calc(' + dOptions.top + ' - ' + (templateSize.height / 2) + 'px)';

                    initLoad = true;

                    spinner.css({ 'top': topCalc, 'left': ((windowWidth / 2) - (templateSize.width / 2)) });

                    if (dOptions.isOverlay) {
                        overlay.prependTo(element);
                    }
                    spinner.prependTo(element);
                }

                scope.$watch(function () {
                    return scope.isLoaded;
                }, watcher);

                function watcher(newVal, oldVal) {
                    if (newVal === false) {
                        timer = $timeout(function () {
                            spinner.stop().fadeIn();
                            overlay.stop().fadeIn();
                        }, 150);
                    } else {
                        spinner.stop().fadeOut();
                        overlay.stop().fadeOut();
                        $timeout.cancel(timer);
                    }
                }
            }
        };
    };

})(jQuery);

(function () {
    angular.module('globalApp').directive('ocsSticky',
        ['$timeout', sticky]);

    function sticky($timeout) {
        return {
            link: link,
            scope: {
                update: "=",
                slideInside: "@"
            }
        }

        function link(scope, elem, attr) {
            $timeout(sticky, 1000);

            function sticky() {
                angular.element(document).ready(function () {
                    elem.wrap('<div class="wrap"></div>'); // wrap it up
                    var inclosure = $(scope.slideInside);

                    $('<div class="sticky-stop"></div>').insertAfter(inclosure);// stop it!

                    var wrap = elem.parent();
                    var parent = wrap.parent();
                    parent.css({ 'position': 'static' });
                    var sidebarheight, mainheight;
                    var topOffset = attr.offset;
                    var cushion = 0; // cushion for spapping to the bottom 

                    function measureheight() {
                        wrap.css({ 'width': parent.width() });
                        sidebarheight = elem.outerHeight() + cushion;
                        mainheight = inclosure.outerHeight();
                        if (mainheight - sidebarheight > 0) {
                            inclosure.waypoint(function (direction) {
                                $(this).toggleClass('sticky', direction === 'down');
                            });
                            $('.sticky-stop').waypoint(function (direction) {
                                inclosure.toggleClass('at-bottom', direction === 'down');
                            }, {
                                offset: function () {
                                    return sidebarheight;
                                }
                            })
                        } else {
                            $().waypoint('destroy');
                        }
                    };

                    measureheight();

                    //used for inclosure height change.
                    scope.$watch('update', function (newVal, oldVal) {
                        if (newVal !== oldVal) {
                            $timeout(measureheight, 10);
                        }
                    });
                    $(window).resize(measureheight);
                });
            }
        }
    }
})();
(function () {
    "use strict";
    globalApp.directive("ocsTextarea", ['$rootScope', '$log', '$parse', 'templateUrlService', directiveFunction]);

    function directiveFunction($rootScope, $log, $parse, templateUrlService) {
        return {
            restrict: "E",
            scope: {
                meta: "=",
                model: "=",
                match: "@"
            },

            templateUrl: templateUrlService.get('ocs-Textarea.html'),

            replace: true,
            transclude: false,
            link: function (scope, element, attrs) {
                // this incriments the global counter and creates a new uneque ID
                if ($rootScope.IdCounter === undefined) { $rootScope.IdCounter = 0; }
                scope.elementId = "elem_" + $rootScope.IdCounter++;


                //allows to resize the form
                scope.formSize = attrs.formSize;

                // look up mask name and resolve, if not found then pass value as is
                //temp = $rootScope.productVariables.standardMask[scope.meta.mask];
                //if (temp == undefined) { scope.mask = scope.meta.mask; } else { scope.mask = temp; }

                // allows training sapce char on passwords
                if (scope.meta) {
                    if (scope.meta.type === "password") { scope.trim = false; }
                }

                if (attrs.options !== undefined) {
                    var options = $parse(attrs.options)(scope);
                    element.find('textarea').attr('rows', options.rows);
                }
            }
        };

    };

})();

(function () {
    'use strict';
    angular.module('globalApp').directive('ocsUpload', ['$parse', '$rootScope', '$log', 'FileUploader', 'authenticationStorage', 'documentUpload', '_', 'templateUrlService', directiveFunction]);

    function directiveFunction($parse, $rootScope, $log, FileUploader, authenticationStorage, documentUpload, _, templateUrlService) {
        return {
            restrict: "E",
            scope: {
                meta: "=",                    
                documents: "=",
                extraUploadParams: "=", //extra form params passed with the upload request
                onSuccess: "&",
                onError: "&"
            },

            templateUrl: templateUrlService.get('ocs-Upload.html'),

            link: {
                pre: function (scope, element, attrs) {
                    scope.error = [];
                    var maxItems = (scope.meta && scope.meta.maxItems) || 15;
                    scope.allowedTypes = (scope.meta && scope.meta.allowedTypes) || ['doc', 'docx', 'pdf', 'txt', 'gif', 'jpg', 'rtf'];
                    scope.maxFileSize = (scope.meta && scope.meta.maxFileSize) || 500000;

                    scope.status = {
                        reachedMaxItems: false
                    }

                    scope.$watch("documents.length", function () {
                        checkReachedMaxItems();
                    });
                    
                    var resources;
                    if ($rootScope.productVariables.ChannelID === 10429) {
                        resources = { document: '/trainer/api/me/documents/upload' };
                    } else {
                        resources = { document: '/seeker/api/me/documents/upload' };
                    }

                    var resourceUrl = $rootScope.productVariables.rootUrl + resources['document'];
                    scope.uploader = new FileUploader({
                        url: resourceUrl,
                        withCredentials: false,
                        autoUpload: false,
                        method: 'POST',
                        removeAfterUpload: true,
                        queueLimit: 10
                    });

                    if (typeof scope.extraUploadParams === "object") {
                        _.merge(scope.uploader.formData, scope.extraUploadParams);
                        $log.log('form data: ' + scope.uploader.formData);
                    }

                    scope.uploader.filters.push({
                        name: 'allowedTypeFilter',
                        fn: function (item, options) {                                
                            var fileName = item.name.split('.');
                            var ext = fileName[fileName.length - 1];
                            if (scope.allowedTypes.indexOf(ext) === -1) {
                                return false;                                    
                            }
                            return true;
                        }
                    });

                    scope.uploader.filters.push({
                        name: 'maxSizeFilter',
                        fn: function (item, options) {                                
                            var size = item.size;
                            if (scope.maxFileSize < size) {                                    
                                return false;
                            }
                            return true;
                        }
                    });                        

                    scope.uploader.onWhenAddingFileFailed = function (item, filter, options) {
                        var errorMsg = '';
                        var fileName = item.name.split('.');
                        var ext = fileName[fileName.length - 1];
                        var filterName = filter.name;
                        if (filterName === 'allowedTypeFilter') {                                
                            errorMsg = item.name + ' - file has unsupported extension ' + ext;
                        }
                        if (filterName === 'maxSizeFilter') {                                
                            errorMsg = item.name + ' - size of the file exceeds limit. (' + scope.maxFileSize / 1000 + ' kb)';
                        }

                        onFileValidationError(errorMsg);                            
                    };


                    scope.uploader.onAfterAddingAll = function (addedFileItems) {                            
                        if (scope.documents.length + scope.uploader.queue.length > maxItems || addedFileItems.length < 1) {
                            scope.uploader.clearQueue();
                        } else {
                            uploadAll();
                        }
                    }                        

                    scope.uploader.onBeforeUploadItem = function (item) {
                        //update the request and add necessary payload
                        item.formData.push({ 'name': item.file.name });
                        if (typeof scope.extraUploadParams.type !== "undefined")
                        {
                            item.formData.push({ 'type': scope.extraUploadParams.type });
                        }
                        if (typeof scope.extraUploadParams.referenceValue !== "undefined")
                        {
                            item.formData.push({ 'referenceValue': scope.extraUploadParams.referenceValue });
                        }
                        if (typeof scope.extraUploadParams.referenceType !== "undefined")
                        {
                            item.formData.push({ 'referenceType': scope.extraUploadParams.referenceType });
                        }

                        //supply auth header since the underlying scope.uploader service utilize the XMLHttpRequest directly (our http injector is not triggered)
                        //this might be fixed in future release (see https://github.com/nervgh/angular-file-upload/milestones/3.0.0)
                        item.headers = {
                            'Authorization': 'Bearer ' + authenticationStorage.getToken(),
                            'ChannelID': $rootScope.productVariables.ChannelID,
                            'AppID': $rootScope.productVariables.ApplicationID
                        };
                    };

                    scope.uploader.onSuccessItem = function (item) {
                        var fileName = item.file.name;                            
                        onUploadSuccess(fileName);
                    };

                    scope.uploader.onErrorItem = function (item, response) {
                        if (item.cloudInfo === undefined) {
                            onUploadError(item.file.name);                                
                        }
                    };                                                

                    scope.upload = function () {                                                        
                        uploadAll();
                    };

                    scope.browse = function () {
                        var fileUploadEl = angular.element('#fileUpload');
                        fileUploadEl.val(null);
                        fileUploadEl.click();
                    }                                                                        

                    //support for google drive picker                
                    scope.onGDrivePicked = function (fileInfo) {

                        var fileMeta = fileInfo.meta;

                        var file = {
                            name: fileMeta.title,
                            size: fileMeta.fileSize,
                            type: fileMeta.fileExtension,
                            url: fileMeta.downloadUrl,
                            token: fileInfo.token
                        };
                        addToUploadQueue(file);
                        scope.$apply();
                    }

                    //support for google drive picker                
                    scope.onDropBoxPicked = function (filesInfo) {

                        var fileMeta = filesInfo[0];

                        var fileInfo = {
                            name: fileMeta.name,
                            size: fileMeta.bytes,
                            type: getFileSuffix(fileMeta.name),
                            url: fileMeta.link
                        };
                        addToUploadQueue(fileInfo);
                        scope.$apply();
                    }                        

                    function addToUploadQueue(fileInfo) {
                        var fileItem = new FileUploader.FileItem(scope.uploader, {});                            
                        fileItem.file = { name: fileInfo.name, size: fileInfo.size };
                        fileItem.size = fileInfo.size;
                        fileItem.type = fileInfo.type;
                        fileItem.cloudInfo = {
                            'url': fileInfo.url,
                            'authToken': fileInfo.token,
                            'name': fileInfo.name,
                            'type': scope.extraUploadParams.type,
                            'referenceValue': scope.extraUploadParams.referenceValue,
                            'referenceType': scope.extraUploadParams.referenceType
                        };

                        if (typeof scope.extraUploadParams === "object") {
                            _.merge(fileItem.cloudInfo, _.transform(scope.extraUploadParams, _.ary(_.extend, 2), {}));
                        }

                        fileItem.lastModifiedDate = new Date();
                        fileItem.name = fileInfo.name;                            
                        scope.uploader.addToQueue(fileItem);
                    }                        

                    function displayUploadResult(isSuccess, fileName) {
                        var msgSuffix = isSuccess ? ' uploaded' : ' failed to upload';
                        $log.log(" Document " + fileName + msgSuffix);
                    }

                    function getFileSuffix(fileName) {
                        var fileSuffix = "";
                        if (fileName.indexOf(".") >= 0) {
                            var aFileNameParts = fileName.split(".");
                            if (aFileNameParts.length > 1) {
                                var lastItem = aFileNameParts[aFileNameParts.length - 1];
                                fileSuffix = lastItem || '';                                    
                            }
                        }
                        return fileSuffix;
                    }

                    function onUploadSuccess(fileName) {
                        displayUploadResult(true, fileName);
                        if (typeof scope.onSuccess() === "function") {
                            scope.error = [];
                            scope.onSuccess()();
                        }
                    }

                    function checkReachedMaxItems() {
                        if (maxItems && scope.documents && scope.uploader && scope.uploader.queue) {
                            if ((scope.documents.length + scope.uploader.queue.length) >= maxItems) {
                                scope.status.reachedMaxItems = true;
                            } else {
                                scope.status.reachedMaxItems = false;
                            }
                        }
                    }

                    function onUploadError(fileName) {
                        displayUploadResult(false, fileName);
                        var err = { type: 'alert-danger', text: 'Unable to upload file ' + fileName };
                        if (typeof scope.onError() === "function") {
                            scope.onError()(err);
                        } else {
                            scope.error.push(err);
                        }
                    }

                    function onFileValidationError(errorMsg) {                            
                        var err = { type: 'alert-danger', text: errorMsg };
                        if (typeof scope.onError() === "function") {
                            scope.onError()(err);
                        } else {
                            scope.error.push(err);
                        }
                    }

                    function localFileUpload(item) {
                        scope.uploader.uploadItem(item);
                    }

                    function cloudFileUpload(item) {

                        scope.uploader.removeFromQueue(item);

                        //console.log(item.cloudInfo);                            
                        documentUpload.uploadFromCloud({}, item.cloudInfo).$promise.then(
                            function (response) {
                                onUploadSuccess(response.name);
                            }, function (response) {
                                onUploadError(response.config.data.docName);
                            });
                    }

                    function uploadAll() {
                        angular.forEach(scope.uploader.queue, function (item) {
                            if (item.cloudInfo) {
                                cloudFileUpload(item);
                            } else {
                                localFileUpload(item);
                                //console.log(item);
                            }
                        });
                    }                        
                }
            }
        };
    };
})();

(function () {
    angular.module('globalApp')
    .directive("ocsZipCode", ['$rootScope', '$log', 'geoLocation', 'templateUrlService', function ($rootScope, $log, geoLocation, templateUrlService) {
        return {
            restrict: "E",
            scope: {
                meta: "=",
                model: "=",
                state: "=",
                county: "="
            },
            require: '^form', //Needed to traverse up to find form controller

            templateUrl: templateUrlService.get('ocs-ZipCode.html'),

            replace: true,
            link: link
        };

        function link(scope, element, attrs, ctrl) {

            // uneque id creator
            if ($rootScope.IdCounter === undefined) { $rootScope.IdCounter = 0; }
            scope.elimentId = "elem_" + $rootScope.IdCounter++;

            // listen for changes in the model
            scope.$watch(function () {
                return scope.model;
            },
            //when model changes do this
            function handleZipChange(newValue, oldValue) {
                if (newValue) {
                        if (newValue.length === 5 && (!angular.equals(newValue, oldValue) || !scope.isSet)) {
                            ctrl.$setValidity('minlength', true);
                            scope.isSet = true;
                            geoLocation.get({ zipCode: newValue }).$promise.then(
                                function (data) { //success
                                    if (data.isError && data.isError !== undefined) {
                                        scope.county = data.county;
                                        scope.errorMessage = data.message;
                                        ctrl.$setValidity('wrong', false);
                                        return;
                                    }
                                    if (parseInt(scope.state) != data.stateId) {
                                        ctrl.$setValidity('nomatch', false);
                                        return;
                                    }
                                    scope.errorMessage = null;
                                    scope.county = data.county;
                                },
                                function (error) { //error
                                    scope.errorMessage(error.data.message);
                                    scope.county = null;
                                });
                        } else {
                            if (!element.find('input').val()) {
                                scope.county = null;
                            }
                            ctrl.$setValidity('wrong', true);
                            ctrl.$setValidity('nomatch', true);
                            ctrl.$setValidity('minlength', false);
                        }
                    }

                
                });

            
            
            }
    }]);
})();



(function () {

    angular.module('globalApp').run(['$rootScope', 'channelConfig', 'dataSourceService', 'resolveLayoutConfigs', '$q', 'cacheService', '_', 'menuCreator', 'resolveMetaMessages', 'resolveMetaConfigs', 'resolveDataSource', 'resolveTracking', 'timeoutManager', 'authenticationStorage',
    function ($rootScope, channelConfig, dataSourceService, resolveLayoutConfigs, $q, cacheService, _, menuCreator, resolveMetaMessages, resolveMetaConfigs, resolveDataSource, resolveTracking, timeoutManager, authenticationStorage) {

        //
        //                                                                      _________________
        // ____________________________________________________________________/  Init variables \___________
        if (!$rootScope.config) { $rootScope.config = {}; }
        if (!$rootScope.serverMessagesObj) { $rootScope.serverMessagesObj = {}; }

        //
        //                                                                      ____________________
        // ____________________________________________________________________/  pre-resolve Phase \___________

        $rootScope.preResolvePhase = function (metaObject, msgObject, cfgObject) {
        //dataScourceList = findAlldataSource($rootScope.meta);
            
            return $q.all([
                    resolveMetaMessages.init(),
                    resolveLayoutConfigs.init(),
                    resolveMetaConfigs.init(),
                    resolveDataSource.init(),
                    resolveTracking.init()


            ]).then(function (results) {
                $rootScope.meta.nav1 = menuCreator.create($rootScope.meta.menuConfig, $rootScope.meta.navMasterItems);
                $rootScope.meta.breadCrumbs = menuCreator.createBreadCrumbs($rootScope.meta.menuConfig, $rootScope.meta.navMasterItems);
                $rootScope.$watch('isAuthenticated', function (newValue, oldValue) {
                    if (newValue === true) {
                        timeoutManager.start({
                            showWarning: $rootScope.cfg('sessionTimeout.showWarning'),
                            timeToWarning: $rootScope.cfg('sessionTimeout.timeToWarning'),
                            timeToLogOut: $rootScope.cfg('sessionTimeout.timeToLogOut')
                        });
                    }
                });
                authenticationStorage.setAuthenticateUsingSaml($rootScope.cfg('authenticateUsingSAML'));
                authenticationStorage.setIdpAuthCookieName($rootScope.cfg('idpAuthCookieName'));

                //alert('hello');

                return results;
            });
        };

    }]);


})();


(function(angular) { angular.module("globalApp").service("coreUiTemplateService",  ["$templateCache", function($templateCache) { return { init: function() {$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-401.html","<div ng-show=\"!$root.isAuthenticated\">\r\n    <div class=\"row\">\r\n        <div class=\"col-sm-6\">\r\n            <div class=\"panel panel-muted\">\r\n                <div class=\"panel-body\">\r\n\r\n                    <h2 class=\"mt0 h3\" ng-bind-html=\"$root.msg(363999)\"></h2>\r\n                    <p ng-bind-html=\"$root.msg(364000)\"></p>\r\n\r\n                    <div class=\"row\">\r\n                        <div class=\"col-sm-12\">\r\n                            <div class=\"btn-group pull-right\" role=\"group\" aria-label=\"...\">\r\n                                <a ng-click=\"createAccount()\" type=\"button\" class=\"btn btn-info\">{{$root.msg(204843)}}</a>\r\n                            </div>\r\n                        </div>\r\n                    </div>\r\n\r\n                </div>\r\n            </div>\r\n        </div>\r\n        <div class=\"col-sm-6\">\r\n            <ocs-login meta=\"meta\"></ocs-login>\r\n        </div>\r\n    </div>\r\n</div>");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-AccordionSteps.html","<div>\r\n\r\n    <uib-accordion close-others=\"true\">\r\n        <ng-form name=\'{{key}}\' novalidate ng-repeat=\"(key,a) in meta[accordionName]\">\r\n            <!--{{a.isOpen}}-->\r\n            <uib-accordion-group ng-if=\"a.show\"\r\n                                 is-open=\"a.isOpen\"\r\n                                 is-disabled=\"a.isDisabled\"\r\n                                 class=\"panel\"\r\n                                 ng-class=\"{\r\n                                    \'panel-primary\': a.isOpen && !a.isDisabled,\r\n                                    \'panel-default\': !a.isOpen && !a.isDisabled && !{{key}}.$valid,\r\n                                    \'panel-success\': {{key}}.$valid,\r\n                                    \'panel-muted\': a.isDisabled,\r\n                                    \'panel-danger\': {{key}}.$invalid && a.touched,\r\n                                    \'panel-optional\': a.isOptional\r\n                                 }\"\r\n                                 template-url=\"/lib/ui-bootstrap/template/accordion/ui-accordion-group-steps.html\"/>\r\n\r\n                <!--class=\"panel {{a.cssClass}}  disabled-{{a.isDisabled}}\"-->\r\n\r\n                <uib-accordion-heading>\r\n                    <span ng-if=\"a.isNumeric\" class=\"number\">{{stepIndex(key)}}</span> \r\n                    <span ng-if=\"a.heading.lookUpMsg !== undefined\">{{:preResolved:a.heading.lookUpMsg.value}}</span>\r\n                    <span ng-if=\"a.heading.lookUpMsg === undefined\"> {{:preResolved:a.heading}}</span>\r\n                    <div class=\"pull-right\" style=\"padding-top: 2px;\">\r\n                        <i ng-if=\"a.isOpen\" class=\"glyphicon glyphicon-minus\"></i>\r\n                        <i ng-if=\"!a.isOpen && !a.isDisabled\" class=\"glyphicon glyphicon-plus\"></i>\r\n                    </div>\r\n                    \r\n                </uib-accordion-heading>\r\n\r\n                <ng-include src=\"a.url\"></ng-include>\r\n\r\n                <div class=\"btn-group pull-right\" role=\"group\" aria-label=\"Actions\" ng-if=\"!a.noButton\">\r\n                    \r\n                    <!-- remove the skills check, when the input directive is completed (custom errors)  -->\r\n                    <button ng-disabled =\"{{key}}.$invalid || (meta.skillsInError==true)\"\r\n                            ng-if=\"!a.lastOne\"\r\n                            type=\"button\"\r\n                            class=\"btn btn-info\"\r\n                            ng-click=\"moveToNextSection(key,meta.accordion)\" \r\n                            >{{$root.meta.messages[\'AccordionGoButton\'].lookUpMsg.value}}\r\n                    </button>\r\n                </div>\r\n        </ng-form>\r\n    </uib-accordion>\r\n</div>");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-Alert.html","<section class=\"alert-panel\" aria-role=\"alert\" ng-show=\"$root.impersonation.isImpersonating\" ng-bind-html=\"impersonationAlert\">\r\n</section>");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-ApplyNotify.html","<div ng-if=\"show\" class=\"apply-notify\" id=\"currentApplyActive\">\r\n    <span>\r\n        {{ meta.part1.lookUpMsg.text + \' \' + job.name + \' \' + meta.part2.lookUpMsg.text + \' \' + job.company + \' \' + meta.part3.lookUpMsg.text}}\r\n    </span>\r\n    <a ng-click=\"finish()\" href=\"#\">{{ meta.click.lookUpMsg.text }}</a> \r\n    <span>{{ meta.part4.lookUpMsg.text }}</span>\r\n    <a ng-click=\"cancel()\" href=\"#\">{{ meta.click.lookUpMsg.text }}</a> \r\n    <span>{{ meta.part5.lookUpMsg.text }}</span>\r\n</div>");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-AutoComplete.html","<ng-form name=\'singleItemForm\' novalidate>\r\n    <div class=\"form-group\" ng-class=\"{\'has-error\': !(singleItemForm.$pristine || singleItemForm.$valid)}\">\r\n        <label ng-show=\"meta.label.lookUpMsg.value\" for=\'{{:preResolved:elimentId}}_value\' class=\'ng-cloak ng-hide\'>\r\n            <span class=\"ng-hide\">\r\n                {{:preResolved:meta.placeholder.lookUpMsg.value}}\r\n            </span>\r\n            <span ng-show=\'{{:preResolved:meta.required}}\' class=\"ng-hide\">\r\n                <small class=\"fa fa-asterisk required-asterisk\"></small>\r\n            </span>\r\n            {{:preResolved:meta.label.lookUpMsg.value}}\r\n        </label>\r\n        <br ng-show=\"meta.label.lookUpMsg.value\" class=\"ng-hide\" />\r\n        <angucomplete-alt id=\"{{:preResolved:elimentId}}\"\r\n                          placeholder=\'{{:preResolved:meta.placeholder.lookUpMsg.value}}\'\r\n                          pause=\"100\"\r\n                          selected-object=\"model\"\r\n                          local-data=\"meta.items\"\r\n                          search-fields=\"{{:preResolved:meta.searchfields}}\"\r\n                          title-field=\"{{:preResolved:meta.titlefield}}\"\r\n                          remote-api-handler=\"remoteApiHandler\"\r\n                          remote-url-response-formatter=\"remoteResponseFormatter\"\r\n                          input-changed=\"inputChanged\"\r\n                          minlength={{:preResolved:meta.minlength}}\r\n                          validation-mode=\"meta.validationMode\"\r\n                          required=\"meta.required\"\r\n                          custom-validator-names=\"meta.customValidatorNames\"\r\n                          custom-validator-states=\"customValidatorStates\"\r\n                          field-required-class=\"required\"\r\n                          ng-disabled=\"meta.disabled\"\r\n                          input-class=\"{{inputClass}}\"\r\n                          input-name=\"{{:preResolved:elimentId}}\"\r\n                          initial-value=\"initialValue\"\r\n                          match-class=\"highlight\"></angucomplete-alt>\r\n\r\n        <!-- field level validation -->\r\n        <span class=\"error-message ng-hide\" ng-show=\'singleItemForm.$dirty && singleItemForm.$invalid\'>\r\n            <span ng-show=\'singleItemForm.$error.required\'>{{:preResolved:meta.error.required.lookUpMsg.value}}</span>\r\n            <span ng-repeat=\"item in meta.customValidatorNames\">\r\n                <span ng-show=\"singleItemForm.$error[item]\">{{:preResolved:meta.error[item].lookUpMsg.value}}</span>\r\n            </span>\r\n        </span>\r\n    </div>\r\n</ng-form>\r\n");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-BarChart.html","<div class=\"progress position-relative\" style=\"height: 40px;\" ng-repeat=\"item in settings track by $index\" ng-click=\"openAccordion(item.name)\">\r\n    <span class=\"badge position-absolute\" style=\"margin-top: 12px; margin-left: 10px; left:0;\">{{item.name}}</span>\r\n    <div class=\"progress-bar progress-bar-info\" \r\n         role=\"progressbar\" \r\n         aria-valuenow=\"{{item.value}}\" \r\n         aria-valuemin=\"0\" \r\n         aria-valuemax=\"100\" \r\n         ocs-repeater-finished=\"barsRendered\"\r\n         >\r\n    </div>\r\n    <span class=\"badge position-absolute\" style=\"margin-top: 12px; margin-right: 10px; right: 0;\">{{item.value}}%</span>\r\n</div>");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-BreadCrumbs.html","<ol class=\"breadcrumb\" ng-show=\"$root.configLayout.MGS_Breadcrumbs_On.lookUpConfig.value==\'true\'\">\r\n    <li ng-repeat=\"item in $root.meta.breadCrumbs track by $index\">\r\n        <span ng-if=\"!item.url || !meta\">{{:preResolved:item.display.value}}</span>\r\n        <a ng-if=\"item.url && !meta.length == 0\" ng-href=\"{{item.url}}\">{{:preResolved:item.display.value}}</a>\r\n        <span ng-if=\"item.url && meta.length == 0\">{{:preResolved:item.display.value}}</span>\r\n    </li>\r\n    <li ng-repeat=\"item in meta track by $index\">\r\n        <a ng-show=\"item.url\" ng-href=\"{{item.url}}\">{{:preResolved:item.display.lookUpMsg.value}}</a>\r\n        <span ng-hide=\"item.url\">{{item.display.lookUpMsg.value}}</span>\r\n    </li>\r\n</ol>\r\n\r\n");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-Button.html","<button type=\'button\' \r\n        id=\"{{id}}\" \r\n        class=\'btn\' \r\n        ng-disabled=\'isBusy || validation || (meta && meta.disabled)\'>\r\n    {{:preResolved:meta.label.lookUpMsg.value}}\r\n</button>\r\n");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-Calendar.html","<div>\r\n    <div kendo-scheduler=\"scheduler{{calendarId}}\" k-options=\"schedulerOptions\">\r\n    </div>\r\n\r\n    <div ng-repeat=\"entry in legendEntries track by $index\" class=\"display-inline-block\" style=\"margin-right: 15px;\">\r\n        <div>\r\n            <span class=\"display-inline-block\" style=\"background-color:{{ entry.color }}; padding: 2px 7px;\">\r\n                <input type=\"checkbox\" id=\"legendEntry-{{ $index}}\" ng-model=\"entry.checked\" ng-click=\"rebind()\" />\r\n            </span>\r\n            <label for=\"legendEntry-{{ $index }}\">{{ entry.name }}</label>\r\n        </div>\r\n    </div>\r\n</div>");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-Chart.html","<div class=\"svgCanvas\"></div>");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-CheckBox.html","<ng-form name=\'singleItemForm\' novalidate>\r\n    <fieldset class=\'form-group\' ng-disabled=\"meta.disabled\">\r\n        <legend class=\"label-type\">\r\n            <span ng-show=\'{{meta.required}}\'>\r\n                <small class=\"fa fa-asterisk required-asterisk\"></small>\r\n            </span>\r\n            <span ng-bind-html=\"meta.label.lookUpMsg.value\"></span>\r\n            <span ng-show=\'{{meta.required}}\'>\r\n                <span class=\"sr-only\">{{$root.msg(555)}}</span>\r\n            </span>\r\n        </legend>\r\n        <div class=\"checkbox\" ng-repeat=\'n in meta.items\'>\r\n            <label for=\"{{elementID}}-{{n.value}}\">\r\n                <input type=\"checkbox\"\r\n                       id=\"{{elementID}}-{{n.value}}\"\r\n                       ng-disabled=\"{{n.disabled}}\"\r\n                       ng-model=\'$parent.modelTemp[$index]\'\r\n                       name=\'{{elementID}}-{{n.value}}\'\r\n                       ng-true-value=\"{{n.value}}\" />\r\n                <span class=\"checkbox-custom\"></span>\r\n                <span class=\"checkbox-label\">{{:preResolved:n.text}}</span>\r\n            </label>\r\n        </div>\r\n        <span ng-if=\"meta.required\" aria-live=\"assertive\" class=\'error-message\'>\r\n            <span ng-show=\'singleItemForm.$dirty && singleItemForm.$error.required\'>\r\n                <span>{{:preResolved:meta.error.required.lookUpMsg.value}}</span>\r\n            </span>\r\n            &nbsp;\r\n        </span>\r\n        <!--{{model}} | {{modelTemp}}-->\r\n    </fieldset>\r\n</ng-form>\r\n\r\n\r\n\r\n");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-Date.html","<ng-form name=\'singleItemForm\' novalidate>\r\n    <div class=\'form-group\' ng-class=\"{\'form-group-sm\': formSize === \'sm\'}\">\r\n        <label for=\'{{::elementID}}\'>\r\n            <span ng-show=\'{{meta.required}}\'>\r\n                <small class=\"fa fa-asterisk required-asterisk\"></small>\r\n            </span>{{:preResolved:meta.label.lookUpMsg.value}}\r\n        </label>\r\n        <p class=\"input-group\" ng-class=\"{\'open\':status.opened}\">\r\n            <!--\r\n                    ui-mask-placeholder\r\n                    ui-mask=\'{{mask}}\'\r\n                    ng-model-options=\"{ updateOn: \'default blur\', debounce: { \'default\': 200, \'blur\': 0 } }\"\r\n            -->\r\n            \r\n            <input class=\'form-control\' \r\n                   aria-required=\'{{meta.required}}\'\r\n                   ng-change=\'dt\'\r\n                   ng-disabled=\"meta.disabled\" \r\n                   datepicker-popup \r\n                   is-open=\'status.opened\' \r\n                   datepicker-options=\"dateOptions\" \r\n                   uib-datepicker-popup=\'{{format}}\' \r\n                   show-button-bar=\"false\"\r\n                   placeholder=\'{{:preResolved:meta.placeholder.lookUpMsg.value}}\'\r\n                   ocs-match=\"{{match}}\" \r\n                   id=\'{{::elementID}}\' \r\n                   name=\'{{::elementID}}\' \r\n                   MaxLength=\'{{meta.displaymeta.max}}\' \r\n                   ng-model=\'model\' \r\n                   type=\'{{::meta.displaymeta.type}}\' \r\n                   ng-required=\'{{meta.required}}\' />\r\n\r\n            <span class=\"input-group-btn\">\r\n                <button type=\"button\"\r\n                        ng-disabled=\"meta.disabled\"\r\n                        class=\"btn btn-default\" \r\n                        ng-class=\"{\'btn-sm\': formSize === \'sm\'}\"\r\n                        ng-click=\"status.opened = \'true\'\">\r\n                    <i class=\"glyphicon glyphicon-calendar\"></i>\r\n                    <span class=\"sr-only\">Date picker</span>\r\n                </button>\r\n            </span>\r\n        </p>\r\n        <span class=\'error-message ng-hide\' aria-live=\"assertive\" ng-show=\"!singleItemForm.$pristine\">\r\n              <!-- [ {{singleItemForm.$valid}} ]&nbsp;-->\r\n            <!-- field level validation -->\r\n            <span ng-show=\'singleItemForm.$dirty && singleItemForm.$invalid\'>\r\n                <span ng-show=\'singleItemForm.$error.required\'>{{:preResolved:meta.error.required.lookUpMsg.value}}</span>\r\n            </span>\r\n\r\n            <!-- mask level validation -->\r\n            <span ng-show=\'singleItemForm.$error.mask[0].$invalid\'>\r\n                <span>{{:preResolved:meta.error.lookUpMsg.mask.value}}</span>\r\n            </span>\r\n\r\n            <!-- match Validation -->\r\n            <span ng-show=\"singleItemForm.$error.mask[0].$invalid || singleItemForm.$invalid\">\r\n                <span>{{:preResolved:meta.error.lookUpMsg.match.value}}</span>\r\n            </span>\r\n\r\n            <!-- comparison of two date inputs-->\r\n            <span ng-show=\"!singleItemForm.$error.date && singleItemForm.$error.match\">\r\n                {{:preResolved:meta.error.comparison.lookUpMsg.value}}\r\n            </span> \r\n\r\n            <!-- datePicker level validation -->\r\n            <span ng-show=\"singleItemForm.$error.date\">\r\n                Invalid Date Format\r\n            </span>\r\n        </span>\r\n\r\n        <span  ng-hide=\"meta.hideErrorHolder\">\r\n            <span class=\"error-message\" ng-if=\"singleItemForm.$pristine || singleItemForm.$valid\">&nbsp;</span>\r\n        </span>\r\n    </div>\r\n</ng-form>\r\n\r\n");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-Error.html","<div class=\"alert {{x.type}}\" aria-role=\"alert\" ng-repeat=\"(key,x) in errorList\">\r\n    <button ng-click=\"$parent.popError(key);\" class=\"pull-right btn-link\" tabindex=\"0\">Close</button>\r\n    <p>&nbsp;<span ng-bind-html=\"x.text | unsafe\"></span></p>\r\n</div>\r\n");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-FontSize.html","<div class=\"text-resize\">\r\n    <a role=\"button\" title=\"Default font size\">A</a>&nbsp;<a role=\"button\" title=\"Medium font size\">A</a>&nbsp;<a title=\"Large font size\" role=\"button\">A</a>\r\n</div>");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-Help.html","<span ng-if=\"$root.configLayout.helpTextType.lookUpConfig.value === \'1\'\">\r\n    <a href=\"\" class=\"helpIcon\" popover-trigger=\"focus\" title=\"{{:preResolved:meta.title.lookUpMsg.value}}\"\r\n       uib-popover-template=\"\'popOverActivities-4.html\'\" popover-title=\"{{:preResolved:meta.title.lookUpMsg.text}}\">[?]</a>\r\n    <script type=\"text/ng-template\" id=\"popOverActivities-4.html\">\r\n        <p ng-bind-html=\":preResolved:(meta.content.lookUpMsg.text | unsafe)\"></p>\r\n    </script>\r\n</span>\r\n<span ng-if=\"$root.configLayout.helpTextType.lookUpConfig.value === \'2\'\">\r\n    <a href=\"\" class=\"\" title=\"{{:preResolved:meta.title.lookUpMsg.value}}\" ng-click=\"meta.opened=!meta.opened\">[?]</a>\r\n    <small class=\"display-block help-slide\" ng-show=\"meta.opened\" ng-bind-html=\":preResolved:meta.content.lookUpMsg.value | unsafe\"></small>\r\n</span>\r\n\r\n");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-Input.html","<ng-form name=\'singleItemForm\' novalidate>\r\n    <div class=\'form-group\' ng-class=\"{\'has-error\': !(singleItemForm.$pristine || singleItemForm.$valid), \'form-group-sm\': formSize == \'sm\', \'form-group-lg\': formSize == \'lg\'}\">\r\n        <label for=\'{{::elementID}}\' ng-class=\"{\'sr-only\': meta.hideLabel}\">\r\n            <span ng-show=\"meta.required\">\r\n                <small class=\"fa fa-asterisk required-asterisk\"></small>\r\n            </span>{{:preResolved:meta.label.lookUpMsg.value}}\r\n\r\n            <!-- aria-live ? -->\r\n            <ocs-Help meta=\"meta.help\" ng-show=\"{{meta.help}}\" class=\"ng-hide\"></ocs-Help>\r\n        </label>\r\n        <div ng-class=\"{\'input-group\': addOn}\">\r\n            <span ng-if=\"addOn\" class=\"input-group-addon\">{{addOn.text}}</span>\r\n\r\n            <input class=\'form-control\'\r\n                   ng-show=\"meta.autoComplete == null && meta.email == null\"\r\n\r\n                   aria-invalid=\'{{singleItemForm.$invalid}}\'\r\n                   aria-required=\'{{meta.required}}\'\r\n                   ng-disabled=\'meta.disabled\'\r\n                   data-ng-model=\'model\'\r\n                   ocs-only-numbers=\"::meta.decimal\"\r\n                   ng-readonly=\"meta.readonly\"\r\n                   id=\'{{::elementID}}\'\r\n                   ocs-match=\"{{match}}\"\r\n                   ui-mask=\'{{::meta.mask.face}}\'\r\n                   ui-mask-placeholder\r\n                   ui-mask-placeholder-char=\"{{::meta.mask.placeholderChar}}\"\r\n                   placeholder=\'{{(!meta.mask.disableTextPlaceholder && meta.placeholder.lookUpMsg.value || \"\")}}\'\r\n                   maxlength=\'{{::meta.max}}\'\r\n                   type=\'{{meta.type}}\'\r\n                   ng-required=\'{{meta.required}}\'\r\n                   ng-trim=\'{{trim}}\'\r\n                   ng-model-options=\"{ updateOn: \'default\', debounce: { \'default\': 0, \'blur\': 0 } }\"\r\n                   tab-index=\"0\"\r\n                   ng-pattern=\"meta.pattern\"\r\n                    />\r\n\r\n            <input class=\'form-control\'\r\n                   ng-show=\"meta.autoComplete\"\r\n                   ng-change=\'getTypeAhead()\'\r\n\r\n                   list=\'list-{{::elementID}}\'\r\n                   ng-model-options=\'{ debounce: 500 }\'\r\n                   aria-invalid=\'{{singleItemForm.$invalid}}\'\r\n                   aria-required=\'{{meta.required}}\'\r\n                   ng-disabled=\'meta.disabled\'\r\n                   data-ng-model=\'model\'\r\n                   ocs-only-numbers=\"::meta.decimal\"\r\n                   ng-readonly=\"meta.readonly\"\r\n                   id=\'{{::elementID}}\'\r\n                   ocs-match=\"{{match}}\"\r\n                   ui-mask=\'{{::meta.mask.face}}\'\r\n                   ui-mask-placeholder\r\n                   ui-mask-placeholder-char=\"{{::meta.mask.placeholderChar}}\"\r\n                   placeholder=\'{{(!meta.mask.disableTextPlaceholder && meta.placeholder.lookUpMsg.value || \"\")}}\'\r\n                   maxlength=\'{{::meta.max}}\'\r\n                   type=\'{{meta.type}}\'\r\n                   ng-required=\'{{meta.required}}\'\r\n                   ng-trim=\'{{trim}}\'\r\n                   tab-index=\"0\"\r\n                   ng-pattern=\"meta.pattern\"\r\n                    />\r\n\r\n            <input class=\'form-control\'\r\n                   ng-show=\"meta.email\"\r\n                   ng-change=\'checkEmailExists()\'\r\n\r\n                   list=\'list-{{::elementID}}\'\r\n                   ng-model-options=\'{ debounce: 700 }\'\r\n                   aria-invalid=\'{{singleItemForm.$invalid}}\'\r\n                   aria-required=\'{{meta.required}}\'\r\n                   ng-disabled=\'meta.disabled\'\r\n                   data-ng-model=\'model\'\r\n                   ocs-only-numbers=\"::meta.decimal\"\r\n                   ng-readonly=\"meta.readonly\"\r\n                   id=\'{{::elementID}}\'\r\n                   ocs-match=\"{{match}}\"\r\n                   ui-mask=\'{{::meta.mask.face}}\'\r\n                   ui-mask-placeholder\r\n                   ui-mask-placeholder-char=\"{{::meta.mask.placeholderChar}}\"\r\n                   placeholder=\'{{(!meta.mask.disableTextPlaceholder && meta.placeholder.lookUpMsg.value || \"\")}}\'\r\n                   maxlength=\'{{::meta.max}}\'\r\n                   type=\'{{meta.type}}\'\r\n                   ng-required=\'{{meta.required}}\'\r\n                   ng-trim=\'{{trim}}\'\r\n                   tab-index=\"0\"\r\n                   ng-pattern=\"meta.pattern\" />\r\n\r\n\r\n\r\n            <datalist id=\"list-{{::elementID}}\" ng-if=\"meta.autoComplete\">\r\n                <option ng-repeat=\"x1 in meta.autoCompleteData\" value=\"{{model}} - {{x1.text}}\"></option>\r\n            </datalist>\r\n        </div>\r\n\r\n        <!-- this is an IE polyfill for typeahead \"use if needed\" -->\r\n        <!--<div style=\"position:relative;width:200px;height:25px;border:0;padding:0;margin:0;\">\r\n        <select style=\"position:absolute;top:0px;left:0px;width:200px;height:25px;line-height:20px;margin:0;padding:0;\"\r\n                ng-model=\"model.temp\"\r\n                ng-change=\'getTypeAhead()\'>\r\n            <option ng-repeat=\"x1 in autoCompleteData\" value=\"{{model.temp}} - {{x1.text}}\">{{x1.text}}</option>\r\n        </select>\r\n        <input name=\"displayValue\"\r\n               placeholder=\"add/select a value\"\r\n               id=\"displayValue\"\r\n               style=\"position:absolute;top:0px;left:0px;width:183px;width:180px\\9;#width:180px;height:23px;\r\n                height:21px\\9;#height:18px;border:1px solid #556;\"\r\n               onfocus=\"this.select()\" type=\"text\"\r\n               ng-model=\"model.temp\"\r\n               ng-model-options=\'{ debounce: 500 }\'\r\n               ng-change=\'getTypeAhead()\'>\r\n        <input name=\"idValue\" id=\"idValue\" type=\"hidden\">\r\n    </div>-->\r\n\r\n\r\n\r\n\r\n        <!-- <pre>{{meta.blackList}}</pre> -->\r\n        \r\n        \r\n        <span class=\"ng-hide error-message\" aria-live=\"assertive\" ng-show=\"!singleItemForm.$pristine && !meta.hideErrorHolder\">\r\n            <!-- field level validation -->\r\n            <span ng-show=\'singleItemForm.$dirty && singleItemForm.$invalid\'>\r\n                <span ng-show=\'singleItemForm.$error.required\'>\r\n                    {{:preResolved:meta.error.required.lookUpMsg.value}}\r\n                </span>\r\n            </span>\r\n\r\n            <!-- custom add on validations -->\r\n            <span ng-repeat=\"item in meta.customValidatorNames\">\r\n                <span>{{:preResolved:meta.error[item].lookUpMsg.value}}</span>\r\n            </span>\r\n\r\n            <!-- mask level validation -->\r\n            <span ng-show=\'singleItemForm.$error.mask[0].$invalid\'>\r\n                <span>{{:preResolved:meta.error.mask.lookUpMsg.value}}</span>\r\n            </span>\r\n\r\n            <!-- workinf matching validation -->\r\n            <span ng-show=\"singleItemForm.$error.match\">\r\n                <span>{{:preResolved:meta.error.match.lookUpMsg.value}}</span>\r\n            </span>\r\n\r\n            <span ng-show=\"singleItemForm.$error.pattern\">\r\n                <span>{{:preResolved:meta.error.pattern.lookUpMsg.value}}</span>\r\n            </span>\r\n            \r\n            <span ng-show=\"singleItemForm.$error.emailexists\">\r\n                <span>{{:preResolved:meta.error.emailexists.lookUpMsg.value}}</span>\r\n            </span>\r\n            &nbsp;\r\n        </span>\r\n\r\n        <span ng-hide=\"meta.hideErrorHolder\">\r\n            <span class=\"error-message\" ng-if=\"singleItemForm.$pristine || singleItemForm.$valid\">&nbsp;</span>\r\n        </span>\r\n\r\n    </div>\r\n</ng-form>\r\n");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-login.html","<div class=\"row\">\r\n    <ng-form name=\"singleLogInForm\" >\r\n        <form>\r\n            <div class=\"col-md-12\">\r\n                <div class=\"panel panel-primary panel-login\">\r\n                    <div class=\"panel-body equal-padding\">\r\n                        <h3 ng-bind=\"$root.msg(320405)\"></h3>\r\n                        <p ng-if=\"error\" aria-role=\"alert\" class=\"error-message\">{{$root.msg(157552)}}</p>\r\n\r\n                        <ocs-input meta=\"meta.loginEmail\" model=\"userName\"></ocs-input>\r\n                        <ocs-input meta=\"meta.loginPassword\" inputType=\"password\" model=\"password\"></ocs-input>\r\n\r\n                        <p><a href=\"/AccountReset#/forgotPassword\">{{$root.msg(205119)}}</a></p>\r\n\r\n                        <a class=\"btn-match\" ng-click=\"createAccount()\">{{$root.msg(204843)}}</a>\r\n\r\n                        <ocs-button meta=\"meta.signInButton\"\r\n                                    options=\"{classes:\'btn-primary pull-right\', type:\'submit\'}\"\r\n                                    validation=\"singleLogInForm.$invalid\"\r\n                                    ng-click=\"authenticateLogin()\"\r\n                                    is-busy=\"isBusy\"></ocs-button>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </form>\r\n    </ng-form>\r\n</div>\r\n");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-Modal.html","<div>\r\n    <div ng-transclude></div>\r\n    <div>{{shown}}</div>\r\n</div>");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-NavBar.html","<nav class=\"navbar\" ng-class=\"{\'navbar-inverse\': !defaults.removeInverse}\" role=\"navigation\" id=\"main-navigation\">\r\n    <div class=\"navbar-header\" ng-show=\"defaults.innerMobileButtons\">\r\n        <button type=\"button\" class=\"navbar-toggle collapsed icon-space pull-left\" \r\n                ng-click=\"$root.isSearchCollapsed = !$root.isSearchCollapsed; this.isCollapsed = true;\">\r\n            <span class=\"sr-only\">Toggle search</span>\r\n            <span class=\"fa fa-fw fa-search\"></span>\r\n        </button>\r\n\r\n        <button type=\"button\" class=\"navbar-toggle collapsed\" \r\n                ng-click=\"this.isCollapsed = !this.isCollapsed; $root.isSearchCollapsed = true\">\r\n            <span class=\"sr-only\">Toggle navigation</span>\r\n            <span class=\"icon-bar\"></span>\r\n            <span class=\"icon-bar\"></span>\r\n            <span class=\"icon-bar\"></span>\r\n        </button>\r\n    </div>\r\n    <div class=\"collapse navbar-collapse\" uib-collapse=\"isCollapsed\" aria-live=\"assertive\">\r\n        <ul class=\"nav navbar-nav\">\r\n            <li ng-repeat=\"(key, item) in ::meta track by $index\"\r\n                uib-dropdown\r\n                uib-keyboard-nav\r\n                is-open=\"status.isopen\"\r\n                ng-class=\"{\'open\': status.isopen}\"\r\n                ng-mouseenter=\"open(this)\"\r\n                ng-mouseleave=\"close(this)\">\r\n\r\n                <a ng-if=\":preResolved:item.url && :preResolved:item.icon\" href=\"{{::item.url}}\" tabindex=\"1\">\r\n                    <span ng-class=\"::item.icon\"></span>\r\n                    <span ng-class=\"{\'sr-only\': item.icon}\">{{::item.display}}</span>\r\n                </a>\r\n\r\n                <a ng-if=\"!item.url\" ng-href=\"{{::item.url}}\" \r\n                   uib-dropdown-toggle \r\n                   id=\"dropdown-{{::item.display.split(\' \').join(\'-\')}}\" tabindex=\"1\">\r\n                    {{::item.display}}\r\n                    <span ng-if=\"!$parent.defaults.removeCarets\">&nbsp;<span class=\"caret\"></span></span>\r\n                </a>\r\n\r\n                <ul ng-if=\"!item.url\" uib-dropdown-menu aria-labelledby=\"dropdown-{{::item.display.split(\' \').join(\'-\')}}\">\r\n                    <li ng-repeat=\"(key, child) in ::item\" ng-if=\"(key!=\'display\') && (key!=\'icon\') && (key!=\'queryString\')\">\r\n                        <a href=\"{{::child.url}}\" ng-bind-html=\"::child.display\"></a>\r\n                    </li>\r\n                </ul>\r\n            </li>\r\n        </ul>\r\n    </div>\r\n</nav>\r\n");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-Pager.html","<nav class=\"text-center-xs pagination-nav\">\r\n    <ul class=\"pagination pagination-sm\">\r\n        <!-- First -->\r\n        <li ng-show=\"showFirstLast\" ng-class=\"{\'disabled\': currentPage == 0}\">\r\n            <a ng-click=\"setPage(0)\" title=\"{{msg(363528)}}\">\r\n                <span class=\"fa fa-angle-double-left\"></span>\r\n                <span class=\"hidden-xs\" ng-bind=\"::msg(363528)\"></span>\r\n            </a>\r\n        </li>\r\n        <!-- Previous -->\r\n        <li ng-class=\"{\'disabled\': currentPage == 0}\">\r\n            <a ng-click=\"setPage(currentPage - 1)\" title=\"{{msg(363528)}}\">\r\n                <span class=\"fa fa-angle-left\"></span>\r\n                <span class=\"hidden-xs\" ng-bind=\"::msg(363528)\"></span>\r\n            </a>\r\n        </li>\r\n        <!-- Separator && First page ID -->\r\n        <li ng-show=\"showLowerSeparator\">\r\n            <a ng-click=\"setPage(0)\">{{1}}</a>\r\n        </li>\r\n        <li ng-show=\"showLowerSeparator\">\r\n            <span class=\"separator\" role=\"separator\">...</span>\r\n        </li>\r\n        <!-- Page -->\r\n        <li ng-repeat=\"i in range(currentPage)\" ng-class=\"{\'active\': currentPage + 1 == i}\">\r\n            <a ng-click=\"setPage(i - 1)\">{{i}}</a>\r\n        </li>\r\n        <!-- Separator && Last page ID-->\r\n        <li ng-show=\"showUpperSeparator\">\r\n            <span class=\"separator\" role=\"separator\">...</span>\r\n        </li>\r\n        <li ng-show=\"showUpperSeparator\">\r\n            <a ng-click=\"setPage(numberOfPages - 1)\">{{numberOfPages}}</a>\r\n        </li>\r\n        <!-- Next -->\r\n        <li ng-class=\"{\'disabled\': currentPage >= numberOfPages - 1}\">\r\n            <a ng-click=\"setPage(currentPage + 1)\" title=\"{{msg(363527)}}\">\r\n                <span class=\"hidden-xs\" ng-bind=\"::msg(363527)\"></span>\r\n                <span class=\"fa fa-angle-right\"></span>\r\n            </a>\r\n        </li>\r\n        <!-- Last -->\r\n        <li ng-show=\"showFirstLast\" ng-class=\"{\'disabled\': currentPage >= numberOfPages - 1}\">\r\n            <a ng-click=\"setPage(numberOfPages - 1)\" title=\"{{msg(363527)}}\">\r\n                <span class=\"hidden-xs\" ng-bind=\"::msg(363527)\"></span>\r\n                <span class=\"fa fa-angle-double-right\"></span>\r\n            </a>\r\n        </li>\r\n    </ul>\r\n</nav>");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-PasswordAssist.html","<div style=\"background: #f5f7fa; padding: 10px; margin-bottom: 28px;\">\r\n    <p class=\"label-type\">{{meta.requirementTitle.lookUpMsg.value}}</p>\r\n    <ul class=\"list-unstyled\">\r\n        <li>\r\n            <i class=\"fa fa-fw\" ng-class=\"{\'fa-check text-success\': min, \'fa-times text-danger\': !min}\"></i>\r\n            {{defaults.messageMinimumOf}} {{defaults.minLength}} {{defaults.messageCharacters}}\r\n        </li>\r\n        <li>\r\n            <i class=\"fa fa-fw\" ng-class=\"{\'fa-check text-success\': max, \'fa-times text-danger\': !max}\"></i>\r\n            {{defaults.messageLengthShouldNotExceed}} {{defaults.maxLength}} {{defaults.messageCharacters}}\r\n        </li>\r\n        <li>\r\n            <i class=\"fa fa-fw\" ng-class=\"{\'fa-check text-success\': upperLower, \'fa-times text-danger\': !upperLower}\"></i>\r\n            {{defaults.messageContainsUppercaseAndLowercaseLetters}}\r\n        </li>\r\n        <li>\r\n            <i class=\"fa fa-fw\" ng-class=\"{\'fa-check text-success\': digits, \'fa-times text-danger\': !digits}\"></i>\r\n            {{defaults.messageContainsNumbers}}\r\n        </li>\r\n        <li>\r\n            <i class=\"fa fa-fw\" ng-class=\"{\'fa-check text-success\': characters, \'fa-times text-danger\': !characters}\"></i>\r\n            {{defaults.messageContainsSpecialCharacters}}\r\n        </li>\r\n        <li>\r\n            <i class=\"fa fa-fw\" ng-class=\"{\'fa-check text-success\': spaces, \'fa-times text-danger\': !spaces}\"></i>\r\n            {{defaults.messageDoesntContainSpaces}}\r\n        </li>\r\n        <li>\r\n            <i class=\"fa fa-fw\" ng-class=\"{\'fa-check text-success\': isMatched, \'fa-times text-danger\': !isMatched}\"></i>\r\n            {{defaults.messagePasswordsMatch}}\r\n        </li>\r\n    </ul>\r\n</div>");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-Radio.html","<ng-form name=\'singleItemForm\' novalidate>\r\n    <fieldset class=\'form-group\' role=\"radiogroup\" aria-required=\"{{meta.required}}\" ng-disabled=\"meta.disabled\">\r\n        <legend aria-live=\"assertive\" class=\"label-type\" ng-class=\"{\'display-block\': meta.isInline }\" id=\"{{:preResolved:elementLegendID}}\">\r\n            <span ng-show=\'{{:preResolved:meta.required}}\'>\r\n                <small class=\"fa fa-asterisk required-asterisk\"></small>\r\n            </span>\r\n            {{:preResolved:meta.label.lookUpMsg.value}}\r\n            <span ng-show=\'{{:preResolved:meta.required}}\'>\r\n                <span class=\"sr-only\">{{$root.msg(555)}}</span>\r\n            </span>\r\n            <ocs-Help meta=\"meta.help\" ng-show=\"{{meta.help}}\" class=\"ng-hide\"></ocs-Help>\r\n        </legend>\r\n        <div ng-class=\"(meta.isInline)?\'radio-inline\':\'radio\'\" ng-repeat=\'n in :preResolved:meta.items\'>\r\n            <label for=\'{{:preResolved:elementID}}-{{:preResolved:n.value}}\'>\r\n                <input type=\"radio\"\r\n                       name=\"{{:preResolved:elementID}}\"\r\n                       id=\'{{:preResolved:elementID}}-{{:preResolved:n.value}}\'\r\n                       ng-model=\"$parent.model\"\r\n                       ng-value=\'{{:preResolved:n.value}}\'\r\n                       ng-required=\'{{meta.required}}\' \r\n                       aria-labelledby=\"{{:preResolved:elementLegendID}} option_label_{{:preResolved:elementID}}-{{:preResolved:n.value}}\" />\r\n                <span class=\"radio-custom\"></span>\r\n                <span id=\"option_label_{{:preResolved:elementID}}-{{:preResolved:n.value}}\">\r\n                    <span class=\"radio-label\" ng-show=\"!n.text || !n.text.lookUpMsg\">{{:preResolved:n.text}}</span>\r\n                    <span class=\"radio-label\" ng-show=\"n.text && n.text.lookUpMsg\">{{:preResolved:n.text.lookUpMsg.value}}</span>\r\n                </span>\r\n            </label>\r\n        </div>\r\n        <span class=\'error-message\' aria-live=\"assertive\">&nbsp;</span>\r\n    </fieldset>\r\n</ng-form>\r\n");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-RecommendedJobs.html","<div ocs-spinner is-loaded=\"doneLoading\">\r\n    <div class=\"panel panel-default ng-hide\" ng-show=\"jobs !== null && jobs.length > 0\">\r\n        <div class=\"panel-body\">\r\n            <h5><strong>{{$root.meta.recommendedJobs.title.lookUpMsg.value}}</strong></h5>\r\n            <div ng-repeat=\"item in jobs\">\r\n                <hr ng-hide=\"$index === 0\" />\r\n                <a ng-href=\"{{item.url}}\">{{item.title}}</a>\r\n                <div class=\"small\">{{item.html}}</div>\r\n                <small>\r\n                    <span class=\"label label-info\">{{item.city}}, {{item.state}}</span>\r\n                </small>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>\r\n");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-resume-uploaded-preview.html","<div class=\"resume-preview-section\">\r\n    <div class=\"row\">\r\n        <div class=\"col-xs-12\">\r\n            <div>\r\n                <dl>\r\n                    <dt>{{$root.msg(216831)}}</dt>\r\n                    <dd>\r\n                        <div ng-if=\"ctrl.documents[0].fileType != ctrl.fileTypePdf\">\r\n                            <div class=\"well mt16 preview-container\">\r\n                                <div class=\"preview preview-non-pdf\">\r\n                                    <div ng-bind-html=\"ctrl.model.preview.resumeBody\"></div>\r\n                                </div>\r\n                            </div>\r\n                        </div>\r\n                        <div ng-if=\"ctrl.documents[0].fileType == ctrl.fileTypePdf\">\r\n                            <div class=\"row\">\r\n                                <div class=\"col-sm-6\">\r\n                                    <div class=\"text-muted\" ng-if=\"ctrl.pdfDocInfo\">\r\n                                        <div class=\"mt24\">\r\n                                            {{$root.msg(105916)}}: {{ctrl.currentPdfPage}}/{{ctrl.pdfDocInfo.pageNo}}\r\n                                            <a href=\"\" ng-click=\"ctrl.goToPreviousPage()\" title=\"{{$root.msg(113457)}}\" ng-disabled=\"ctrl.currentPdfPage == 1\" class=\"btn btn-default btn-sm\" ng-class=\"{\'disabled\': ctrl.currentPdfPage == 1}\">\r\n                                                <span class=\"fa fa-angle-left\"></span>\r\n                                            </a>\r\n                                            <a href=\"\" ng-click=\"ctrl.goToNextPage()\" title=\"{{$root.msg(113458)}}\" ng-disabled=\"ctrl.currentPdfPage == ctrl.pdfDocInfo.pageNo\" class=\"btn btn-default btn-sm\" ng-class=\"{\'disabled\': ctrl.currentPdfPage == ctrl.pdfDocInfo.pageNo}\">\r\n                                                <span class=\"fa fa-angle-right\"></span>\r\n                                            </a>\r\n                                        </div>\r\n                                    </div>\r\n                                </div>\r\n                                <div class=\"col-sm-6\">\r\n                                    <div class=\"mt24 pull-right text-muted\">\r\n                                        {{$root.msg(369145)}}:\r\n                                        <a href=\"\" ng-click=\"ctrl.pdfZoomIn()\" class=\"btn btn-default btn-sm\" title=\"{{$root.msg(310946)}}\" ng-disabled=\"ctrl.pdfPreviewImgPercentWidth >= ctrl.pdfPreviewImgPercentWidthMax\" ng-class=\"{\'disabled\': ctrl.pdfPreviewImgPercentWidth >= ctrl.pdfPreviewImgPercentWidthMax}\"><span class=\"fa fa-search-plus\"></span></a>\r\n                                        <a href=\"\" ng-click=\"ctrl.pdfZoomOut()\" class=\"btn btn-default btn-sm\" title=\"{{$root.msg(310947)}}\" ng-disabled=\"ctrl.pdfPreviewImgPercentWidth <= ctrl.pdfPreviewImgPercentWidthMin\" ng-class=\"{\'disabled\': ctrl.pdfPreviewImgPercentWidth <= ctrl.pdfPreviewImgPercentWidthMin}\"><span class=\"fa fa-search-minus\"></span></a>\r\n                                    </div>\r\n                                </div>\r\n                            </div>\r\n                            <div class=\"well mt16 preview-container\" ocs-spinner is-loaded=\"!ctrl.loading\">\r\n                                <div ng-if=\"!ctrl.pdfImage\">{{$root.msg(216831)}}...</div>\r\n                                <img ng-show=\"ctrl.pdfImage\" ng-src=\"{{ctrl.pdfImage}}\" style=\"width:{{ctrl.pdfPreviewImgPercentWidth}}%;\" class=\"preview preview-pdf\" alt=\"{{$root.msg(216831)}}\" />\r\n                            </div>\r\n                        </div>\r\n                    </dd>\r\n                </dl>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-RichTextEditor.html","<ng-form name=\'singleItemForm\' novalidate>\r\n    <div class=\'form-group\' ng-class=\"{\'has-error\': !(singleItemForm.$pristine || singleItemForm.$valid)}\">\r\n        <label for=\'{{elimentId}}\'>\r\n            <span ng-show=\'{{meta.required}}\'>\r\n                <small class=\"fa fa-asterisk required-asterisk\"></small>\r\n                <span class=\"sr-only\">{{$root.msg(555)}}</span>\r\n            </span>\r\n            {{meta.label.lookUpMsg.text}}\r\n        </label>\r\n\r\n        <ocs-Help meta=\"meta.help\" ng-show=\"{{meta.help}}\" class=\"ng-hide\"></ocs-Help>\r\n\r\n        <!--\r\n        ui-mask=\'{{mask}}\'\r\n        ui-mask-placeholder\r\n    -->\r\n        <textarea ui-tinymce=\'{{meta.options}}\'\r\n                    aria-label=\"{{meta.label.lookUpMsg.text}} {{meta.required ? $root.msg(555) : \'\'}}\"\r\n                    aria-required=\'{{meta.required}}\'\r\n                    class=\'form-control\'\r\n                    ng-model=\'model\'\r\n                    rows=\"{{meta.rows}}\"\r\n                    placeholder=\'{{meta.placeholder.lookUpMsg.value}}\'\r\n                    max-length=\"{{meta.max}}\"\r\n                    ng-required=\'{{meta.required}}\'\r\n                    ng-model-options=\"{ updateOn: \'default\', debounce: { \'default\': 200, \'change\': 0 }}\"\r\n                    ng-disabled=\"meta.disabled\" />\r\n        <span>{{model.length > 0 ? model.length : 0}}&nbsp;{{meta.of.lookUpMsg.value}}&nbsp;{{meta.max}}</span>\r\n        <span class=\"sr-only\" aria-live=\"assertive\"><span ng-if=\"(model.length % 100) < 50\">{{model.length > 0 ? model.length : 0}}&nbsp;{{meta.of.lookUpMsg.value}}&nbsp;{{meta.max}}</span></span>\r\n\r\n        <span class=\"ng-hide error-message\" ng-show=\"!singleItemForm.$pristine\" aria-live=\"assertive\">\r\n            <!-- [ {{singleItemForm.$valid}} ]&nbsp; -->\r\n            <!-- field level validation -->\r\n            <span ng-show=\'singleItemForm.$dirty && singleItemForm.$invalid\'>\r\n                <span ng-show=\'singleItemForm.$error.required\'>{{meta.error.required.lookUpMsg.value}}</span>\r\n                <span ng-show=\'singleItemForm.$error.maxLength\'>{{meta.error.maxLength.lookUpMsg.value}} <span class=\"sr-only\">{{model.length > 0 ? model.length : 0}}&nbsp;{{meta.of.lookUpMsg.value}}&nbsp;{{meta.max}}</span></span>\r\n            </span>\r\n        </span>\r\n\r\n        <span class=\"error-message\" aria-live=\"assertive\" ng-show=\"singleItemForm.$pristine || singleItemForm.$valid\">&nbsp;</span>\r\n    </div>\r\n</ng-form>\r\n");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-Select.html","<ng-form name=\'singleItemForm\' novalidate>\r\n    <div class=\"form-group\" ng-class=\"{\'has-error\': !(singleItemForm.$pristine || singleItemForm.$valid), \'form-group-sm\': meta.small}\">\r\n        <label for=\'{{elementID}}\' class=\'ng-cloak\'>\r\n            <span ng-show=\'meta.required\'>\r\n                <small class=\"fa fa-asterisk required-asterisk\"></small>\r\n            </span>\r\n            {{:preResolved:meta.label.lookUpMsg.value}}\r\n            <ocs-Help meta=\"meta.help\" ng-show=\"{{meta.help}}\" class=\"ng-hide\"></ocs-Help>\r\n        </label>\r\n        <select id=\"{{elementID}}\"\r\n                aria-required=\'{{meta.required}}\'\r\n                ng-if=\'meta.items[0].text.lookUpMsg\'\r\n                class=\'form-control\'\r\n                ng-model=\'$parent.model\'\r\n                ng-disabled=\'meta.disabled\'\r\n                ng-required=\'meta.required\'\r\n                ng-change=\'changeFn()\'\r\n                name=\"{{meta.label.lookupMessage.value}}\"\r\n                ng-options=\'item.value as item.text.lookUpMsg.value for item in meta.items\'></select>\r\n\r\n        <select id=\"{{elementID}}\"\r\n                aria-required=\'{{meta.required}}\'\r\n                ng-if=\'!meta.items[0].text.lookUpMsg\'\r\n                class=\'form-control\'\r\n                ng-model=\'$parent.model\'\r\n                ng-disabled=\'meta.disabled\'\r\n                ng-required=\'meta.required\'\r\n                ng-change=\'changeFn()\'\r\n                ng-options=\'item.value as item.text disable when item.disabled for item in  meta.items\'\r\n                ></select>\r\n        <!-- field level validation -->\r\n        <span class=\"error-message\" aria-live=\"assertive\">\r\n            <span ng-show=\'singleItemForm.$dirty && singleItemForm.$invalid\' class=\"ng-hide\">\r\n                <span ng-show=\'singleItemForm.$error.required\'>{{:preResolved:meta.error.required.lookUpMsg.value}}</span>\r\n            </span>\r\n            <span class=\"error-message\" ng-show=\"singleItemForm.$pristine || singleItemForm.$valid\"></span>&nbsp;\r\n            &nbsp;\r\n        </span>\r\n    </div>\r\n\r\n</ng-form>\r\n");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-Spinner.html","<div class=\"text-center\">\r\n    <i class=\'fa fa-spinner fa-spin fa-3x\'></i>\r\n</div>");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-Textarea.html","<ng-form name=\'singleItemForm\' novalidate>\r\n    <div class=\'form-group\' ng-class=\"{\'has-error\': !(singleItemForm.$pristine || singleItemForm.$valid), \'form-group-sm\': formSize === \'sm\'}\">\r\n        <label for=\'{{::elementId}}\' class=\"display-block\" ng-class=\"{\'sr-only\': meta.isForCheckbox}\">\r\n            <span ng-show=\"meta.required\">\r\n                <small class=\"fa fa-asterisk required-asterisk\"></small>\r\n            </span>\r\n            {{:preResolved:meta.label.lookUpMsg.value}}\r\n            \r\n            <ocs-Help meta=\"meta.help\" ng-show=\"{{meta.help}}\" class=\"ng-hide\"></ocs-Help>\r\n            <span class=\"small pull-right\" ng-if=\"::meta.counter\">\r\n                {{model.length > 0 ? model.length : 0}}&nbsp;{{:preResolved:meta.of.lookUpMsg.value}}&nbsp;{{meta.max}}\r\n            </span>\r\n        </label>\r\n\r\n       \r\n\r\n        <!--\r\n            ui-mask=\'{{mask}}\'\r\n            ui-mask-placeholder\r\n        -->\r\n        <textarea class=\'form-control\'\r\n                  aria-required=\'{{meta.required}}\'\r\n                  data-ng-model=\'model\' \r\n                  id=\'{{::elementId}}\'\r\n                  rows=\"{{::meta.rows}}\"\r\n                  placeholder=\'{{:preResolved:meta.placeholder.lookUpMsg.value}}\'\r\n                  MaxLength=\'{{::meta.max}}\'\r\n                  type=\'{{::meta.type}}\'\r\n                  ng-required=\'meta.required\'\r\n                  ng-model-options=\"{ updateOn: \'default\', debounce: { \'default\': 200, \'blur\': 0 } }\"\r\n                  ng-disabled=\"::meta.disabled\" />\r\n                \r\n\r\n        <span class=\"ng-hide error-message\" ng-show=\"!singleItemForm.$pristine\">\r\n            <!-- field level validation -->\r\n            <span ng-show=\'singleItemForm.$dirty && singleItemForm.$invalid\'>\r\n                <span ng-show=\'singleItemForm.$error.required\'>{{:preResolved:meta.error.required.lookUpMsg.value}}</span>\r\n            </span>\r\n            <!-- mask level validation -->\r\n            <span ng-show=\'singleItemForm.$error.mask[0].$invalid\'>\r\n                <span>{{:preResolved:meta.error.mask.lookUpMsg.value}}</span>\r\n            </span>\r\n        </span>\r\n        <span class=\"error-message\" aria-live=\"assertive\" ng-hide=\"meta.hideErrorHolder\" ng-if=\"singleItemForm.$pristine || singleItemForm.$valid\">&nbsp;</span>\r\n    </div>\r\n</ng-form>\r\n");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-Upload.html","<div class=\"row\">\r\n    <div class=\"col-md-12\">\r\n        <h4>{{:preResolved:$root.msg(365792)}}</h4>\r\n    </div>\r\n    <div class=\"col-md-4\">\r\n        <button type=\"button\"\r\n                class=\"btn btn-info btn-file btn-block\"\r\n                ng-click=\"browse()\"\r\n                ng-disabled=\"status.reachedMaxItems\">\r\n            <span class=\"fa fa-cloud-upload\"></span> {{:preResolved:$root.msg(181227)}}\r\n        </button>\r\n    </div>\r\n    <div class=\"col-md-4\">\r\n        <button type=\"button\"\r\n                class=\"btn btn-info btn-file btn-block\"\r\n                lk-google-picker\r\n                on-picked=\"onGDrivePicked(fileInfo)\"\r\n                ng-disabled=\"status.reachedMaxItems\">\r\n            <span class=\"fa fa-cloud-upload\"></span> {{:preResolved:$root.msg(319437)}}\r\n        </button>\r\n    </div>\r\n    <div class=\"col-md-4\">\r\n        <button type=\"button\"\r\n                class=\"btn btn-info btn-file btn-block\"\r\n                drop-box-picker\r\n                on-picked=\"onDropBoxPicked(filesInfo)\"\r\n                ng-disabled=\"status.reachedMaxItems\">\r\n            <span class=\"fa fa-cloud-upload\"></span> {{:preResolved:$root.msg(320202)}}\r\n        </button>\r\n        <input type=\"file\" id=\"fileUpload\" nv-file-select uploader=\"uploader\" ng-show=\"false\" aria-label=\"{{:preResolved:$root.msg(181227)}}\" ng-disabled=\"status.reachedMaxItems\" />\r\n        <br />\r\n    </div>\r\n\r\n    <div class=\"col-md-12 hidden-xs\" >\r\n        <div class=\"text-center my-drop-zone\" style=\"border:  1px dashed gray;\" nv-file-drop nv-file-over=\"\" uploader=\"uploader\" ng-class=\"{disabledarea: status.reachedMaxItems}\">\r\n            <br />\r\n            <br />\r\n            {{:preResolved:$root.msg(365793)}}\r\n            <br />\r\n            <br><br>\r\n        </div>\r\n    </div>\r\n</div>");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ocs-ZipCode.html","<ng-form name=\'singleItemForm\' novalidate>\r\n    <div class=\'form-group\' ng-class=\"{\'has-error\': !(singleItemForm.$pristine || singleItemForm.$valid)}\">\r\n        <label for=\'{{:preResolved:elimentId}}\'>\r\n            <span ng-show=\'{{:preResolved:meta.required}}\'><small class=\"fa fa-asterisk required-asterisk\"></small></span> {{:preResolved:meta.label.lookUpMsg.value}}\r\n            <ocs-Help meta=\"meta.help\" ng-show=\"{{meta.help}}\" class=\"ng-hide\"></ocs-Help>\r\n        </label>\r\n\r\n        \r\n\r\n        <input class=\'form-control\'\r\n               aria-required=\'{{meta.required}}\'\r\n               ng-model=\'model\'\r\n               id=\'{{:preResolved:elimentId}}\'\r\n               placeholder=\'{{:preResolved:meta.placeholder.lookUpMsg.value}}\'\r\n               MaxLength=\'5\'\r\n               type=\'text\'\r\n               ng-required=\'{{:preResolved:meta.required}}\'\r\n               ng-model-options=\"{ updateOn: \'default\', debounce: { \'default\': 200, \'blur\': 0 } }\"\r\n               ng-disabled=\":preResolved:meta.disabled\" />\r\n\r\n\r\n        <span class=\"error-message ng-hide\" ng-show=\"!singleItemForm.$pristine\">\r\n            <span ng-show=\'singleItemForm.$dirty && singleItemForm.$invalid\'>\r\n                <span ng-show=\'singleItemForm.$error.required\'>{{meta.error.required.lookUpMsg.value}}</span>\r\n            </span>\r\n\r\n            <!-- workinf matching validation -->\r\n            <span ng-show=\"singleItemForm.$error.wrong\">\r\n                <span>{{:preResolved:meta.error.wrong.lookUpMsg.value}}</span>\r\n            </span>\r\n\r\n            <span ng-show=\"singleItemForm.$error.nomatch\">\r\n                <span>{{:preResolved:meta.error.nomatch.lookUpMsg.value}}</span>\r\n            </span>\r\n\r\n            <span ng-show=\"singleItemForm.$error.minlength\">\r\n                <span>{{:preResolved:meta.error.minlength.lookUpMsg.value}}</span>\r\n            </span>\r\n        </span>\r\n\r\n        <span class=\"error-message\" aria-live=\"assertive\" ng-show=\"singleItemForm.$pristine || singleItemForm.$valid\">&nbsp;</span>\r\n    </div>\r\n</ng-form>\r\n");
$templateCache.put("https://core.ui.lexus.monster.com/uiCore/templates/ui-accordion-group-steps.html","<div class=\"panel\" ng-class=\"panelClass || \'panel-default\'\">\r\n    <div class=\"panel-heading\" ng-keypress=\"toggleOpen($event)\" ng-click=\"toggleOpen()\">\r\n        <h2 class=\"panel-title\">\r\n            <!-- note: add |tabindex=\"0\"| below for 508 on IE 9+ -->\r\n            <span class=\"accordion-toggle\" uib-accordion-transclude=\"heading\">\r\n                <span ng-class=\"{\'text-muted\': isDisabled}\">{{heading}}</span>\r\n                <i class=\"check-mark fa fa-check pull-right\"></i>\r\n            </span>\r\n            \r\n\r\n        </h2>\r\n    </div>\r\n    <div class=\"panel-collapse collapse\" uib-collapse=\"!isOpen\">\r\n        <div class=\"panel-body\" ng-transclude></div>\r\n    </div>\r\n</div>\r\n");} }; }]); })(angular);